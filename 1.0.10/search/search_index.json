{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>slackblocks</code>!","text":"<p><code>slackblocks</code> is Python package for creating complex Slack messages      using the Slack BlockKit API.</p> <p>It exists so you don't have to define block-based Slack messages by     hand-writing JSON.</p>"},{"location":"#components","title":"Components","text":"<p>The Slack BlockKit API defines a number of      different resource types (all defined in JSON) which work together to      define Block-based messages.</p> <p><code>slackblocks</code> makes using this API easier by providing a hierarchy of Python     classes that represent these resources.</p>"},{"location":"#objects","title":"Objects","text":"<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream <code>Objects</code> (e.g. <code>Text</code>)      are the lowest level pimitives that are used to populate      <code>Elements</code> and <code>Blocks</code>.</p>"},{"location":"#elements","title":"Elements","text":"<p><code>Elements</code> are typically interactive UI elements that take     in <code>Object</code> to define their content. For example, the      <code>CheckboxGroup</code> element takes in one or     more <code>Option</code> items and presents a     checkbox menu to the user with those options.</p>"},{"location":"#blocks","title":"Blocks","text":"<p><code>Blocks</code> are the core element of the API, with different      <code>Blocks</code> used to create different types of visual     elements. For example, the <code>DividerBlock</code>,      when rendered, will show a visual element similar to a <code>&lt;hr&gt;</code> HTML element. The     <code>RichTextBlock</code> on the other hand ======= <code>Objects</code> (e.g. <code>Text</code>)      are the lowest level pimitives that are used to populate      <code>Elements</code> and <code>Blocks</code>.</p>"},{"location":"#elements_1","title":"Elements","text":"<p><code>Elements</code> are typically interactive UI elements that take     in <code>Object</code> to define their content. For example, the      <code>CheckboxGroup</code> element takes in one or     more <code>Option</code> items and presents a     checkbox menu to the user with those options.</p>"},{"location":"#blocks_1","title":"Blocks","text":"<p><code>Blocks</code> are the core element of the API, with different      <code>Blocks</code> used to create different types of visual     elements. For example, the <code>DividerBlock</code>,      when rendered, will show a visual element similar to a <code>&lt;hr&gt;</code> HTML element. The     <code>RichTextBlock</code> on the other hand</p> <p>Stashed changes     allows for the display of text elements with visual styling like italics,     block quotes, lists and code blocks. </p>"},{"location":"#messages","title":"Messages","text":"<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream <code>Messages</code> are a convenience wrapper around <code>Blocks</code> that ======= <code>Messages</code> are a convenience wrapper around <code>Blocks</code> that</p> <p>Stashed changes     can be unpacked as arguments straight into the official Slack Python SDK (or     its legacy <code>slackclient</code> counterpart).</p>"},{"location":"#views","title":"Views","text":"<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream <code>Views</code> are an alternative usage for <code>Blocks</code> ======= <code>Views</code> are an alternative usage for <code>Blocks</code></p> <p>Stashed changes     that allow for the creation of custom UI \"surfaces\" within Slack, e.g. for      third-party apps.</p>"},{"location":"#guides","title":"Guides","text":"<p>In addition to a complete reference of all classes and functions provided by the      <code>slackblocks</code> library, this documentation contains guides on:</p> <ul> <li>Installing <code>slackblocks</code></li> <li>Using Blocks</li> <li>Sending Block-based Messages</li> </ul>"},{"location":"reference/attachments/","title":"Attachments","text":"<p>Warning: Deprecated Feature</p> <p>Attachments, while still accepted by the Slack API, have long (for years now) been considered a deprecated feature.</p> <p>That said, there is currently no other way to achieve the vertical, colored bars next to content.</p> <p>Secondary (less important) content can be attached using the deprecated attachments API.</p> <p>See: https://api.slack.com/slackblocks/latest/reference/messaging/attachments.</p>"},{"location":"reference/attachments/#attachments.Attachment","title":"Attachment","text":"<p>Lower priority content can be attached to messages using Attachments. This is content that doesn't necessarily need to be seen to appreciate the intent of the message, but perhaps adds further context or additional information.</p> <p>See https://api.slack.com/reference/messaging/attachments.</p> <p>N.B: <code>fields</code> is a deprecated field, included only for legacy purposes. Other legacy fields, e.g. <code>author_name</code> are deliberately omitted as they were never implemented in <code>slackblocks</code>.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>Optional[Union[Block, List[Block]]]</code> <p>an array of Blocks that define the content of the attachment.</p> <code>None</code> <code>color</code> <code>Optional[Union[str, Color]]</code> <p>the color (in hex format, e.g. #ffffff) of the vertical bar to the left of the attachment content. Consider using the <code>Color</code> enum from this module.</p> <code>None</code> <code>fields</code> <code>Optional[Union[Field, List[Field]]]</code> <p>a list of <code>Field</code> objects to be included in what's rendered in the attachment.</p> <code>None</code> Throws <p>InvalidUsageError: if the <code>color</code> code provided is invalid.</p> Source code in <code>slackblocks/attachments.py</code> <pre><code>class Attachment:\n    \"\"\"\n    Lower priority content can be attached to messages using Attachments.\n    This is content that doesn't necessarily need to be seen to appreciate\n    the intent of the message, but perhaps adds further context or additional information.\n\n    See &lt;https://api.slack.com/reference/messaging/attachments&gt;.\n\n    N.B: `fields` is a deprecated field, included only for legacy purposes. Other legacy\n    fields, e.g. `author_name` are deliberately omitted as they were never implemented in\n    `slackblocks`.\n\n    Args:\n        blocks: an array of Blocks that define the content of the attachment.\n        color: the color (in hex format, e.g. #ffffff) of the vertical bar to the left of the\n            attachment content. Consider using the `Color` enum from this module.\n        fields: a list of `Field` objects to be included in what's rendered in the attachment.\n\n    Throws:\n        InvalidUsageError: if the `color` code provided is invalid.\n    \"\"\"\n\n    def __init__(\n        self,\n        blocks: Optional[Union[Block, List[Block]]] = None,\n        color: Optional[Union[str, Color]] = None,\n        fields: Optional[Union[Field, List[Field]]] = None,\n    ):\n        self.blocks = coerce_to_list(blocks, Block, allow_none=True)\n        self.fields = coerce_to_list(fields, Field, allow_none=True)\n        if type(color) is Color:\n            self.color = color.value\n        elif type(color) is str:\n            if len(color) == 7 and color.startswith(\"#\") and is_hex(color[1:]):\n                self.color = color\n            elif len(color) == 6 and is_hex(color):\n                self.color = f\"#{color}\"\n            else:\n                raise InvalidUsageError(\n                    \"Color must be a valid hex code (e.g. `#ffffff`)\"\n                )\n        else:\n            self.color = None\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        attachment = dict()\n        if self.blocks:\n            attachment[\"blocks\"] = [block._resolve() for block in self.blocks]\n        if self.color:\n            attachment[\"color\"] = self.color\n        return attachment\n\n    def __repr__(self) -&gt; str:\n        return dumps(self._resolve(), indent=4)\n</code></pre>"},{"location":"reference/attachments/#attachments.Color","title":"Color","text":"<pre><code>Color is a utility class for use with the Slack secondary attachments API.\n\nPass these to the `color` argument of\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         <code>Attachment</code>. =======         <code>Attachment</code>.</p> <p>Stashed changes</p> <pre><code>&lt;table style=\"width:50%\"&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.GOOD&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='good' src='https://readme-swatches.vercel.app/4CAF50?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.WARNING&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='warning' src='https://readme-swatches.vercel.app/FFEB3B?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.DANGER&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='danger' src='https://readme-swatches.vercel.app/F44336?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.RED&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='red' src='https://readme-swatches.vercel.app/ff0000?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.BLUE&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='blue' src='https://readme-swatches.vercel.app/0000ff?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.YELLOW&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='yellow' src='https://readme-swatches.vercel.app/ffff00?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.GREEN&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='green' src='https://readme-swatches.vercel.app/00ff00?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.ORANGE&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='orange' src='https://readme-swatches.vercel.app/ff8800?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.PURPLE&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='purple' src='https://readme-swatches.vercel.app/8800ff?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;Color.BLACK&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;\n&lt;img valign='middle' alt='black' src='https://readme-swatches.vercel.app/000000?style=round'/&gt;\n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n</code></pre> Source code in <code>slackblocks/attachments.py</code> <pre><code>class Color(Enum):\n    \"\"\"\n    Color is a utility class for use with the Slack secondary attachments API.\n\n    Pass these to the `color` argument of\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        [`Attachment`](/slackblocks/latest/reference/attachments/#attachments.Attachment).\n=======\n        [`Attachment`](/slackblocks/reference/attachments/#attachments.Attachment).\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n\n    &lt;table style=\"width:50%\"&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.GOOD&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='good' src='https://readme-swatches.vercel.app/4CAF50?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.WARNING&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='warning' src='https://readme-swatches.vercel.app/FFEB3B?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.DANGER&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='danger' src='https://readme-swatches.vercel.app/F44336?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.RED&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='red' src='https://readme-swatches.vercel.app/ff0000?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.BLUE&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='blue' src='https://readme-swatches.vercel.app/0000ff?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.YELLOW&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='yellow' src='https://readme-swatches.vercel.app/ffff00?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.GREEN&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='green' src='https://readme-swatches.vercel.app/00ff00?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.ORANGE&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='orange' src='https://readme-swatches.vercel.app/ff8800?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.PURPLE&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='purple' src='https://readme-swatches.vercel.app/8800ff?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n    &lt;td&gt;&lt;code&gt;Color.BLACK&lt;/code&gt;&lt;/td&gt;\n    &lt;td&gt;\n    &lt;img valign='middle' alt='black' src='https://readme-swatches.vercel.app/000000?style=round'/&gt;\n    &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;/table&gt;\n    \"\"\"\n\n    GOOD = \"good\"\n    WARNING = \"warning\"\n    DANGER = \"danger\"\n    RED = \"#ff0000\"\n    BLUE = \"#0000ff\"\n    YELLOW = \"#ffff00\"\n    GREEN = \"#00ff00\"\n    ORANGE = \"#ff8800\"\n    PURPLE = \"#8800ff\"\n    BLACK = \"#000000\"\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;slackblocks Color {self.name}: {self.value}&gt;\"\n</code></pre>"},{"location":"reference/attachments/#attachments.Field","title":"Field","text":"<p>Field text objects for use with Slack's secondary attachment API.</p> <p>See https://api.slack.com/reference/messaging/attachments#fields.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Optional[str]</code> <p>text shown as a bold heading on the field.</p> <code>None</code> <code>value</code> <code>Optional[str]</code> <p>text (<code>mrkdwn</code> or <code>plaintext</code>) representing the value of the field.</p> <code>None</code> <code>short</code> <code>Optional[bool]</code> <p>whether the contents of the field is short enough to be presented in multipe columns.</p> <code>False</code> Source code in <code>slackblocks/attachments.py</code> <pre><code>class Field:\n    \"\"\"\n    Field text objects for use with Slack's secondary attachment API.\n\n    See &lt;https://api.slack.com/reference/messaging/attachments#fields&gt;.\n\n    Args:\n        title: text shown as a bold heading on the field.\n        value: text (`mrkdwn` or `plaintext`) representing the value of the field.\n        short: whether the contents of the field is short enough to be presented in\n            multipe columns.\n    \"\"\"\n\n    def __init__(\n        self,\n        title: Optional[str] = None,\n        value: Optional[str] = None,\n        short: Optional[bool] = False,\n    ):\n        self.title = title\n        self.value = value\n        self.short = short\n\n    def _resolve(self):\n        field = dict()\n        field[\"short\"] = self.short\n        if self.title:\n            field[\"title\"] = self.title\n        if self.value:\n            field[\"value\"] = self.value\n        return dumps(field)\n</code></pre>"},{"location":"reference/blocks/","title":"Blocks","text":"<p>Blocks are a series of container components that can be combined to create rich and interactive messages.</p> <p>See: https://api.slack.com/reference/block-kit/blocks.</p>"},{"location":"reference/blocks/#blocks.ActionsBlock","title":"ActionsBlock","text":"<pre><code>A `Block` that is used to hold interactive elements (normally for users to interface with).\n\nArgs:\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         elements: a list of Elements             (up to a maximum of 25). =======         elements: a list of Elements (up to a maximum of 25).</p> <p>Stashed changes         block_id: you can use this field to provide a deterministic identifier for the block.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the items in `elements` are invalid.\n</code></pre> Source code in <code>slackblocks/blocks.py</code> <pre><code>class ActionsBlock(Block):\n    \"\"\"\n    A `Block` that is used to hold interactive elements (normally for users to interface with).\n\n    Args:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        elements: a list of [Elements](/slackblocks/latest/reference/elements)\n            (up to a maximum of 25).\n=======\n        elements: a list of [Elements](/slackblocks/reference/elements) (up to a maximum of 25).\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n        block_id: you can use this field to provide a deterministic identifier for the block.\n\n    Throws:\n        InvalidUsageError: if any of the items in `elements` are invalid.\n    \"\"\"\n\n    def __init__(\n        self,\n        elements: Optional[List[Element]] = None,\n        block_id: Optional[str] = None,\n    ) -&gt; \"ActionsBlock\":\n        super().__init__(type_=BlockType.ACTIONS, block_id=block_id)\n        self.elements = coerce_to_list(\n            elements, (Element), allow_none=True, max_size=25\n        )\n\n    def _resolve(self):\n        actions = self._attributes()\n        actions[\"elements\"] = [element._resolve() for element in self.elements]\n        return actions\n</code></pre>"},{"location":"reference/blocks/#blocks.ContextBlock","title":"ContextBlock","text":"<p>A <code>ContextBlock</code> displays contextul message info, including both images and text.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Optional[List[Union[Element, CompositionObject]]]</code> <p>a list of <code>Text</code> objects and <code>Image</code> elements.</p> <code>None</code> <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> <code>None</code> Throws <p>InvalidUsageError: when items in <code>elements</code> are not <code>Text</code> or <code>Image</code> or exceed 10 items.</p> Source code in <code>slackblocks/blocks.py</code> <pre><code>class ContextBlock(Block):\n    \"\"\"\n    A `ContextBlock` displays contextul message info, including both images and text.\n\n    Args:\n        elements: a list of `Text` objects and `Image` elements.\n        block_id: you can use this field to provide a deterministic identifier for the block.\n\n    Throws:\n        InvalidUsageError: when items in `elements` are not `Text` or `Image` or exceed 10 items.\n    \"\"\"\n\n    def __init__(\n        self,\n        elements: Optional[List[Union[Element, CompositionObject]]] = None,\n        block_id: Optional[str] = None,\n    ) -&gt; \"ContextBlock\":\n        super().__init__(type_=BlockType.CONTEXT, block_id=block_id)\n        self.elements = []\n        for element in elements:\n            if (\n                element.type == CompositionObjectType.TEXT\n                or element.type == ElementType.IMAGE\n            ):\n                self.elements.append(element)\n            else:\n                raise InvalidUsageError(\n                    f\"Context blocks can only hold image and text elements, not {element.type}\"\n                )\n        if len(self.elements) &gt; 10:\n            raise InvalidUsageError(\"Context blocks can hold a maximum of ten elements\")\n\n    def _resolve(self) -&gt; Dict[str, any]:\n        context = self._attributes()\n        context[\"elements\"] = [element._resolve() for element in self.elements]\n        return context\n</code></pre>"},{"location":"reference/blocks/#blocks.DividerBlock","title":"DividerBlock","text":"<p>A content divider, like an <code>&lt;hr&gt;</code> in HTML, to split up different blocks inside of a message.</p> <p>Parameters:</p> Name Type Description Default <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> <code>None</code> Source code in <code>slackblocks/blocks.py</code> <pre><code>class DividerBlock(Block):\n    \"\"\"\n    A content divider, like an `&lt;hr&gt;` in HTML, to split up different blocks inside of\n    a message.\n\n    Args:\n        block_id: you can use this field to provide a deterministic identifier for the block.\n    \"\"\"\n\n    def __init__(self, block_id: Optional[str] = None) -&gt; \"DividerBlock\":\n        super().__init__(type_=BlockType.DIVIDER, block_id=block_id)\n\n    def _resolve(self):\n        return self._attributes()\n</code></pre>"},{"location":"reference/blocks/#blocks.FileBlock","title":"FileBlock","text":"<p>Displays a remote file (e.g. a PDF).</p> <p>For details on how remote files are exposed to Slack, see https://api.slack.com/messaging/files#adding.</p> <p>Parameters:</p> Name Type Description Default <code>external_id</code> <code>str</code> <p>the ID assigned to the remote file when it was added to Slack.</p> required <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> required <code>source</code> <code>str</code> <p>always \"remote\" as per the Slack API (may change in the future).</p> <code>'remote'</code> Source code in <code>slackblocks/blocks.py</code> <pre><code>class FileBlock(Block):\n    \"\"\"\n    Displays a remote file (e.g. a PDF).\n\n    For details on how remote files are exposed to Slack, see\n    &lt;https://api.slack.com/messaging/files#adding&gt;.\n\n    Args:\n        external_id: the ID assigned to the remote file when it was added to Slack.\n        block_id: you can use this field to provide a deterministic identifier for the block.\n        source: always \"remote\" as per the Slack API (may change in the future).\n    \"\"\"\n\n    def __init__(\n        self, external_id: str, block_id: Optional[str], source: str = \"remote\"\n    ) -&gt; \"FileBlock\":\n        super().__init__(type_=BlockType.FILE, block_id=block_id)\n        self.external_id = external_id\n        self.source = source\n\n    def _resolve(self) -&gt; Dict[str, any]:\n        file = self._attributes()\n        file[\"external_id\"] = self.external_id\n        file[\"source\"] = self.source\n        return file\n</code></pre>"},{"location":"reference/blocks/#blocks.HeaderBlock","title":"HeaderBlock","text":"<p>A Header Block is a plain-text block that displays in a larger, bold font.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Union[str, Text]</code> <p>the text that will be rendered as a heading.</p> required <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> <code>None</code> Source code in <code>slackblocks/blocks.py</code> <pre><code>class HeaderBlock(Block):\n    \"\"\"\n    A Header Block is a plain-text block that displays in a larger, bold font.\n\n    Args:\n        text: the text that will be rendered as a heading.\n        block_id: you can use this field to provide a deterministic identifier for the block.\n    \"\"\"\n\n    def __init__(\n        self, text: Union[str, Text], block_id: Optional[str] = None\n    ) -&gt; \"HeaderBlock\":\n        super().__init__(type_=BlockType.HEADER, block_id=block_id)\n        if type(text) is Text:\n            self.text = text\n        else:\n            self.text = Text(text, type_=TextType.PLAINTEXT, verbatim=False)\n\n    def _resolve(self) -&gt; Dict[str, any]:\n        header = self._attributes()\n        header[\"text\"] = self.text._resolve()\n        return header\n</code></pre>"},{"location":"reference/blocks/#blocks.ImageBlock","title":"ImageBlock","text":"<p>An Image Block contains a single graphic, accessed by URL.</p> <p>Parameters:</p> Name Type Description Default <code>image_url</code> <code>str</code> <p>the URL pointing to the image file you want to display.</p> required <code>alt_text</code> <code>Optional[str]</code> <p>alternative text for accessibility purposes and when the image fails to load.</p> <code>' '</code> <code>title</code> <code>Optional[Union[Text, str]]</code> <p>an optional text title to be presented with the image.</p> <code>None</code> <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> <code>None</code> Throws <p>InvalidUsageError: when one or more of the provided args fails validation.</p> Source code in <code>slackblocks/blocks.py</code> <pre><code>class ImageBlock(Block):\n    \"\"\"\n    An Image Block contains a single graphic, accessed by URL.\n\n    Args:\n        image_url: the URL pointing to the image file you want to display.\n        alt_text: alternative text for accessibility purposes and when the image fails to load.\n        title: an optional text title to be presented with the image.\n        block_id: you can use this field to provide a deterministic identifier for the block.\n\n    Throws:\n        InvalidUsageError: when one or more of the provided args fails validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        image_url: str,\n        alt_text: Optional[str] = \" \",\n        title: Optional[Union[Text, str]] = None,\n        block_id: Optional[str] = None,\n    ) -&gt; \"ImageBlock\":\n        super().__init__(type_=BlockType.IMAGE, block_id=block_id)\n        self.image_url = validate_string(\n            string=image_url,\n            field_name=\"title\",\n            max_length=3000,\n        )\n        self.alt_text = validate_string(\n            alt_text, field_name=\"alt_text\", max_length=2000\n        )\n        if title and isinstance(title, Text):\n            if title.text_type == TextType.MARKDOWN:\n                # Coerce title into plaintext\n                self.title = Text(\n                    text=title.text,\n                    type_=TextType.PLAINTEXT,\n                    emoji=title.emoji,\n                    verbatim=title.verbatim,\n                )\n            else:\n                self.title = title\n        elif isinstance(title, str):\n            self.title = Text(text=title, type_=TextType.PLAINTEXT)\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        image = self._attributes()\n        image[\"image_url\"] = self.image_url\n        if self.alt_text:\n            image[\"alt_text\"] = self.alt_text\n        if self.title:\n            image[\"title\"] = self.title._resolve()\n        return image\n</code></pre>"},{"location":"reference/blocks/#blocks.InputBlock","title":"InputBlock","text":"<pre><code>A block that collects information from users - it can hold a plain-text\ninput element, a checkbox element, a radio button element, a select\nmenu element, a multi-select menu element, or a datepicker.\n\nArgs:\n    label: the name which identifies the input field.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         element: an interactive Element             (e.g. a text field).         dispatch_action: whether the Element             should trigger the sending of a <code>block_actions</code> payload. =======         element: an interactive Element (e.g. a text field).         dispatch_action: whether the Element should trigger the             sending of a <code>block_actions</code> payload.</p> <p>Stashed changes         block_id: you can use this field to provide a deterministic identifier for the block.         hint: an optional additional guide on what input the user should prodive.         optional: whether this input field may be empty when the user submits e.g. the modal.</p> <pre><code>Throws:\n    InvalidUsageError: when any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/blocks.py</code> <pre><code>class InputBlock(Block):\n    \"\"\"\n    A block that collects information from users - it can hold a plain-text\n    input element, a checkbox element, a radio button element, a select\n    menu element, a multi-select menu element, or a datepicker.\n\n    Args:\n        label: the name which identifies the input field.\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        element: an interactive [Element](/slackblocks/latest/reference/elements)\n            (e.g. a text field).\n        dispatch_action: whether the [Element](/slackblocks/latest/reference/elements)\n            should trigger the sending of a `block_actions` payload.\n=======\n        element: an interactive [Element](/slackblocks/reference/elements) (e.g. a text field).\n        dispatch_action: whether the [Element](/slackblocks/reference/elements) should trigger the\n            sending of a `block_actions` payload.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n        block_id: you can use this field to provide a deterministic identifier for the block.\n        hint: an optional additional guide on what input the user should prodive.\n        optional: whether this input field may be empty when the user submits e.g. the modal.\n\n    Throws:\n        InvalidUsageError: when any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        label: TextLike,\n        element: Element,\n        dispatch_action: bool = False,\n        block_id: Optional[str] = None,\n        hint: Optional[TextLike] = None,\n        optional: bool = False,\n    ) -&gt; \"InputBlock\":\n        super().__init__(type_=BlockType.INPUT, block_id=block_id)\n        self.label = Text.to_text(\n            label, force_plaintext=True, max_length=2000, allow_none=False\n        )\n        if not isinstance(element, ALLOWED_INPUT_ELEMENTS):\n            raise InvalidUsageError(\"\")\n        self.element = element\n        self.dispatch_action = dispatch_action\n        self.hint = Text.to_text(\n            hint, force_plaintext=True, max_length=2000, allow_none=True\n        )\n        self.optional = optional\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        input_block = self._attributes()\n        input_block[\"label\"] = self.label._resolve()\n        input_block[\"element\"] = self.element._resolve()\n        if self.hint:\n            input_block[\"hint\"] = self.hint._resolve()\n        if self.dispatch_action:\n            input_block[\"dispatch_action\"] = self.dispatch_action\n        if self.optional:\n            input_block[\"optional\"] = self.optional\n        return input_block\n</code></pre>"},{"location":"reference/blocks/#blocks.RichTextBlock","title":"RichTextBlock","text":"<pre><code>A RichTextBlock is used to provide easier rich text formatting\n    than standard markdown text (e.g. in a\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         <code>SectionBlock</code>)         and access to text formatting features not available in traditional         markdown (e.g. strikethrough). See the various rich text elements         you can include here. =======         <code>SectionBlock</code>)         and access to text formatting features not available in traditional         markdown (e.g. strikethrough). See the various rich text elements         you can include here.</p> <p>Stashed changes</p> <pre><code>Args:\n    elements: a single [rich text element](rich_text)\n        or a list of those elements.\n    block_id: you can use this field to provide a deterministic identifier\n        for the block.\n\nThrows:\n    InvalidUsageError: if the elements in `elements` are not valid rich\n        text elements.\n</code></pre> Source code in <code>slackblocks/blocks.py</code> <pre><code>class RichTextBlock(Block):\n    \"\"\"\n    A RichTextBlock is used to provide easier rich text formatting\n        than standard markdown text (e.g. in a\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        [`SectionBlock`](/slackblocks/latest/reference/blocks/#blocks.SectionBlock))\n        and access to text formatting features not available in traditional\n        markdown (e.g. strikethrough). See the various rich text elements\n        you can include [here](/slackblocks/latest/reference/rich_text).\n=======\n        [`SectionBlock`](/slackblocks/reference/blocks/#blocks.SectionBlock))\n        and access to text formatting features not available in traditional\n        markdown (e.g. strikethrough). See the various rich text elements\n        you can include [here](/slackblocks/reference/rich_text).\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n\n    Args:\n        elements: a single [rich text element](rich_text)\n            or a list of those elements.\n        block_id: you can use this field to provide a deterministic identifier\n            for the block.\n\n    Throws:\n        InvalidUsageError: if the elements in `elements` are not valid rich\n            text elements.\n    \"\"\"\n\n    def __init__(\n        self,\n        elements: Union[RichTextObject, List[RichTextObject]],\n        block_id: Optional[str] = None,\n    ) -&gt; \"RichTextBlock\":\n        super().__init__(type_=BlockType.RICH_TEXT, block_id=block_id)\n        self.elements = coerce_to_list(\n            elements,\n            (\n                RichTextList,\n                RichTextCodeBlock,\n                RichTextQuote,\n                RichTextSection,\n            ),\n            min_size=1,\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        rich_text_block = self._attributes()\n        rich_text_block[\"elements\"] = [element._resolve() for element in self.elements]\n        return rich_text_block\n</code></pre>"},{"location":"reference/blocks/#blocks.SectionBlock","title":"SectionBlock","text":"<pre><code>A section is one of the most flexible blocks available -\nit can be used as a simple text block, or with any of the\navailable block elements.\n\nSection blocks can also optionally be given an \"accessory,\"\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream     which is typically one of the interactive     Elements. =======     which is typically one of the interactive Elements.</p> <p>Stashed changes</p> <pre><code>Args:\n    text: text to include in the block. Can be a string or `Text` object (of either\n        `mrkdwn` or `plaintext` variety). Defaults to markdown if unspecified. One of either\n        `text` or `fields` must be provided.\n    block_id: you can use this field to provide a deterministic identifier for the block.\n    fields: a list of text objects. One of either `text` or `fields` must be provided.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         accessory: an optional Element object that             will take a secondary place in the block (after or to the side of  <code>text</code> or             <code>fields</code>). =======         accessory: an optional Element object that will take a             secondary place in the block (after or to the side of  <code>text</code> or <code>fields</code>).</p> <p>Stashed changes</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation checks.\n</code></pre> Source code in <code>slackblocks/blocks.py</code> <pre><code>class SectionBlock(Block):\n    \"\"\"\n    A section is one of the most flexible blocks available -\n    it can be used as a simple text block, or with any of the\n    available block elements.\n\n    Section blocks can also optionally be given an \"accessory,\"\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n    which is typically one of the interactive\n    [Elements](/slackblocks/latest/reference/elements).\n=======\n    which is typically one of the interactive [Elements](/slackblocks/reference/elements).\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n\n    Args:\n        text: text to include in the block. Can be a string or `Text` object (of either\n            `mrkdwn` or `plaintext` variety). Defaults to markdown if unspecified. One of either\n            `text` or `fields` must be provided.\n        block_id: you can use this field to provide a deterministic identifier for the block.\n        fields: a list of text objects. One of either `text` or `fields` must be provided.\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        accessory: an optional [Element](/slackblocks/latest/reference/elements) object that\n            will take a secondary place in the block (after or to the side of  `text` or\n            `fields`).\n=======\n        accessory: an optional [Element](/slackblocks/reference/elements) object that will take a\n            secondary place in the block (after or to the side of  `text` or `fields`).\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation checks.\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Optional[TextLike] = None,\n        block_id: Optional[str] = None,\n        fields: Optional[Union[TextLike, List[TextLike]]] = None,\n        accessory: Optional[Element] = None,\n    ) -&gt; \"SectionBlock\":\n        super().__init__(type_=BlockType.SECTION, block_id=block_id)\n        if not text and not fields:\n            raise InvalidUsageError(\n                \"Must supply either `text` or `fields` or `both` to SectionBlock.\"\n            )\n        self.text = Text.to_text(text, max_length=3000, allow_none=True)\n        self.fields = coerce_to_list(\n            (\n                [\n                    Text.to_text(field, max_length=2000, allow_none=False)\n                    for field in coerce_to_list(\n                        fields, class_=(str, Text), allow_none=True\n                    )\n                ]\n                if fields\n                else None\n            ),\n            class_=Text,\n            allow_none=True,\n            max_size=10,\n        )\n\n        self.accessory = accessory\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        section = self._attributes()\n        if self.text:\n            section[\"text\"] = self.text._resolve()\n        if self.fields:\n            section[\"fields\"] = [field._resolve() for field in self.fields]\n        if self.accessory:\n            section[\"accessory\"] = self.accessory._resolve()\n        return section\n</code></pre>"},{"location":"reference/elements/","title":"Elements","text":"<p>Block elements can be used inside of section, context, input, and actions layout blocks.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements</p>"},{"location":"reference/elements/#elements.Button","title":"Button","text":"<p>An interactive element that inserts a button. The button can be a trigger for anything from opening a simple link to starting a complex workflow.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#button.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>TextLike</code> <p>text on the button (plaintext only; max 75 chars).</p> required <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>url</code> <code>Optional[str]</code> <p>a URL to load in the user's browser when the button is clicked.</p> <code>None</code> <code>value</code> <code>Optional[str]</code> <p>the value sent with the interaction payload.</p> <code>None</code> <code>style</code> <code>Optional[str]</code> <p>the visual style of the button, one of <code>primary</code>, <code>danger</code>.</p> <code>None</code> <code>confirm</code> <code>Optional[ConfirmationDialogue]</code> <p>a <code>ConfirmationDialogue</code> object that will be presented when the button is clicked.</p> <code>None</code> <code>accessibility_label</code> <code>Optional[str]</code> <p>a string label for longer descriptive text about a button element. Used by screen readers (max 75 chars).</p> <code>None</code> <p>Throws:     InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class Button(Element):\n    \"\"\"\n    An interactive element that inserts a button. The button can be a\n    trigger for anything from opening a simple link to starting a complex\n    workflow.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#button&gt;.\n\n    Args:\n        text: text on the button (plaintext only; max 75 chars).\n        action_id: an identifier so the source of the action can be known.\n        url: a URL to load in the user's browser when the button is clicked.\n        value: the value sent with the interaction payload.\n        style: the visual style of the button, one of `primary`, `danger`.\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the button is clicked.\n        accessibility_label: a string label for longer descriptive text about\n            a button element. Used by screen readers (max 75 chars).\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        text: TextLike,\n        action_id: str,\n        url: Optional[str] = None,\n        value: Optional[str] = None,\n        style: Optional[str] = None,\n        confirm: Optional[ConfirmationDialogue] = None,\n        accessibility_label: Optional[str] = None,\n    ) -&gt; \"Button\":\n        super().__init__(type_=ElementType.BUTTON)\n        self.text = Text.to_text(text, max_length=75, force_plaintext=True)\n        self.action_id = validate_action_id(action_id)\n        self.url = validate_string(\n            url, field_name=\"url\", max_length=3000, allow_none=True\n        )\n        self.value = validate_string(\n            value,\n            field_name=\"value\",\n            max_length=2000,\n            allow_none=True,\n        )\n        self.style = style.value if isinstance(style, ButtonStyle) else style\n        self.confirm = confirm\n        self.accessibility_label = validate_string(\n            accessibility_label,\n            \"accessibility_label\",\n            max_length=75,\n            allow_none=True,\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        button = self._attributes()\n        button[\"text\"] = self.text._resolve()\n        button[\"action_id\"] = self.action_id\n        if self.style:\n            button[\"style\"] = self.style\n        if self.url:\n            button[\"url\"] = self.url\n        if self.value:\n            button[\"value\"] = self.value\n        if self.confirm:\n            button[\"confirm\"] = self.confirm._resolve()\n        if self.accessibility_label:\n            button[\"accessibility_label\"] = self.accessibility_label\n        return button\n</code></pre>"},{"location":"reference/elements/#elements.ButtonStyle","title":"ButtonStyle","text":"<p>Utility class for determining the style of <code>Buttons</code> and <code>WorkflowButtons</code>.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class ButtonStyle(Enum):\n    \"\"\"\n    Utility class for determining the style of `Buttons` and `WorkflowButtons`.\n    \"\"\"\n\n    DEFAULT = None\n    PRIMARY = \"primary\"\n    DANGER = \"danger\"\n\n    @staticmethod\n    def to_button_style(style: Optional[Union[\"ButtonStyle\", str]]) -&gt; \"ButtonStyle\":\n        if isinstance(style, ButtonStyle):\n            return style\n        if isinstance(style, (str, None)):\n            return ButtonStyle[style]\n        raise InvalidUsageError(\n            f\"Can only coerce to ButtonStyle from ButtonStyle or string, not {type(style)}.\"\n        )\n</code></pre>"},{"location":"reference/elements/#elements.ChannelMultiSelectMenu","title":"ChannelMultiSelectMenu","text":"<p>This interactive UI element allows users to select multiple channels visible     to the current user in the active workspace.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#channel_multi_select.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_channels</code> <code>Optional[List[str]]</code> <p>a list of conversation IDs as strings that will already be selected when the menu renders.</p> <code>None</code> <code>confirm</code> <code>ConfirmationDialogue</code> <p>a <code>ConfirmationDialogue</code> object that will be presented when the menu is used.</p> <code>None</code> <code>max_selected_items</code> <code>Optional[int]</code> <p>the maximum number of items that can be selected in the menu.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the menu will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the menu when it's initially rendered.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class ChannelMultiSelectMenu(Element):\n    \"\"\"\n    This interactive UI element allows users to select multiple channels visible\n        to the current user in the active workspace.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#channel_multi_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_channels: a list of conversation IDs as strings that will\n            already be selected when the menu renders.\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the menu is used.\n        max_selected_items: the maximum number of items that can be selected\n            in the menu.\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the menu when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_channels: Optional[List[str]] = None,\n        confirm: ConfirmationDialogue = None,\n        max_selected_items: Optional[int] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.MULTI_SELECT_CHANNELS)\n        self.action_id = validate_action_id(action_id)\n        self.initial_channels = coerce_to_list(\n            initial_channels, class_=str, allow_none=True\n        )\n        self.confirm = confirm\n        self.max_selected_items = max_selected_items\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, force_plaintext=True, max_length=150, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        channel_multi_select = self._attributes()\n        channel_multi_select[\"action_id\"] = self.action_id\n        if self.initial_channels:\n            channel_multi_select[\"initial_channels\"] = [\n                initial_option._resolve() for initial_option in self.initial_channels\n            ]\n        if self.confirm:\n            channel_multi_select[\"confirm\"] = self.confirm._resolve()\n        if self.max_selected_items:\n            channel_multi_select[\"max_selected_items\"] = self.max_selected_items\n        if self.focus_on_load:\n            channel_multi_select[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            channel_multi_select[\"placeholder\"] = self.placeholder._resolve()\n        return channel_multi_select\n</code></pre>"},{"location":"reference/elements/#elements.ChannelSelectMenu","title":"ChannelSelectMenu","text":"<p>A select menu interactive UI element, sourced with a list of public channels visible     to the current user.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#channels_select.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_channel</code> <code>Optional[str]</code> <p>the single (string) user ID that will be initially selected when first presented to the user.</p> <code>None</code> <code>confirm</code> <code>Optional[ConfirmationDialogue]</code> <p>a <code>ConfirmationDialogue</code> object that will be presented when an option in the overflow menu is selected.</p> <code>None</code> <code>response_url_enabled</code> <code>Optional[bool]</code> <p>When set to true, the view_submission payload from the menu's parent view will contain a response_url. (This response_url can be used for message responses).</p> <code>False</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the input will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the input when it's initially rendered.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class ChannelSelectMenu(Element):\n    \"\"\"\n    A select menu interactive UI element, sourced with a list of public channels visible\n        to the current user.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#channels_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_channel: the single (string) user ID that will be initially selected\n            when first presented to the user.\n        confirm: a `ConfirmationDialogue` object that will be presented when an\n            option in the overflow menu is selected.\n        response_url_enabled: When set to true, the view_submission payload from the\n            menu's parent view will contain a response_url. (This response_url can be\n            used for message responses).\n        focus_on_load: whether or not the input will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the input when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_channel: Optional[str] = None,\n        confirm: Optional[ConfirmationDialogue] = None,\n        response_url_enabled: Optional[bool] = False,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.CHANNELS_SELECT_MENU)\n        self.action_id = validate_action_id(action_id)\n        self.initial_channel = initial_channel\n        self.confirm = confirm\n        self.response_url_enabled = response_url_enabled\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder,\n            max_length=150,\n            force_plaintext=True,\n            allow_none=True,\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        channel_select_menu = self._attributes()\n        channel_select_menu[\"action_id\"] = self.action_id\n        if self.initial_channel:\n            channel_select_menu[\"initial_channel\"] = self.initial_channel\n        if self.confirm:\n            channel_select_menu[\"confirm\"] = self.confirm._resolve()\n        if self.response_url_enabled:\n            channel_select_menu[\"response_url_enabled\"] = self.response_url_enabled\n        if self.focus_on_load:\n            channel_select_menu[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            channel_select_menu[\"placeholder\"] = self.placeholder._resolve()\n        return channel_select_menu\n</code></pre>"},{"location":"reference/elements/#elements.CheckboxGroup","title":"CheckboxGroup","text":"<pre><code>A checkbox group that allows a user to choose multiple items from a list\nof possible options.\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#checkboxes&gt;.\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n    options: a list of\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream             <code>Option</code> objects that will             form the content of the checkbox group.         initial_options: a list of             <code>Option</code> objects that will             be initially selected when first presented to the user. =======             <code>Option</code> objects that will form             the content of the checkbox group.         initial_options: a list of             <code>Option</code> objects that will be             initially selected when first presented to the user.</p> <p>Stashed changes         confirm: a <code>ConfirmationDialogue</code> object that will be presented when             the checkbox group is used.         focus_on_load: whether or not the checkbox group will be set to autofocus             within the view object.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class CheckboxGroup(Element):\n    \"\"\"\n    A checkbox group that allows a user to choose multiple items from a list\n    of possible options.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#checkboxes&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        options: a list of\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n            [`Option`](/slackblocks/latest/reference/objects/#objects.Option) objects that will\n            form the content of the checkbox group.\n        initial_options: a list of\n            [`Option`](/slackblocks/latest/reference/objects/#objects.Option) objects that will\n            be initially selected when first presented to the user.\n=======\n            [`Option`](/slackblocks/reference/objects/#objects.Option) objects that will form\n            the content of the checkbox group.\n        initial_options: a list of\n            [`Option`](/slackblocks/reference/objects/#objects.Option) objects that will be\n            initially selected when first presented to the user.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the checkbox group is used.\n        focus_on_load: whether or not the checkbox group will be set to autofocus\n            within the view object.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        options: Union[Option, List[Option]],\n        initial_options: Optional[Union[Option, List[Option]]] = None,\n        confirm: ConfirmationDialogue = None,\n        focus_on_load: bool = False,\n    ) -&gt; \"CheckboxGroup\":\n        super().__init__(type_=ElementType.CHECKBOXES)\n        self.action_id = validate_action_id(action_id)\n        self.options = coerce_to_list(options, Option)\n        self.initial_options = coerce_to_list(initial_options, Option, allow_none=True)\n        self.confirm = confirm\n        self.focus_on_load = focus_on_load\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        checkbox_group = self._attributes()\n        checkbox_group[\"action_id\"] = self.action_id\n        checkbox_group[\"options\"] = [option._resolve() for option in self.options]\n        if self.initial_options:\n            checkbox_group[\"initial_options\"] = [\n                option._resolve() for option in self.initial_options\n            ]\n        if self.confirm:\n            checkbox_group[\"confirm\"] = self.confirm._resolve()\n        if self.focus_on_load:\n            checkbox_group[\"focus_on_load\"] = self.focus_on_load\n        return checkbox_group\n</code></pre>"},{"location":"reference/elements/#elements.ConversationMultiSelectMenu","title":"ConversationMultiSelectMenu","text":"<pre><code>This interactive UI element allows users to select multiple conversations visible\n    to the current user in the active workspace.\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#conversation_multi_select&gt;.\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n    initial_conversations: a list of conversation IDs as strings that will\n        already be selected when the menu renders.\n    default_to_current_conversation: Pre-populates the select menu with the\n        conversation that the user was viewing when they opened the modal\n        (defaults to `False`).\n    confirm: a `ConfirmationDialogue` object that will be presented when\n        the menu is used.\n    max_selected_items: the maximum number of items that can be selected\n        in the menu.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         filter: a <code>Filter</code> =======         filter: a <code>Filter</code></p> <p>Stashed changes             object that filters out conversations that don't match the settings             of the filter.         focus_on_load: whether or not the menu will be set to autofocus             within the view object.         placeholder: a plain-text <code>Text</code> object (max 150 chars) that shows             in the menu when it's initially rendered.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class ConversationMultiSelectMenu(Element):\n    \"\"\"\n    This interactive UI element allows users to select multiple conversations visible\n        to the current user in the active workspace.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#conversation_multi_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_conversations: a list of conversation IDs as strings that will\n            already be selected when the menu renders.\n        default_to_current_conversation: Pre-populates the select menu with the\n            conversation that the user was viewing when they opened the modal\n            (defaults to `False`).\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the menu is used.\n        max_selected_items: the maximum number of items that can be selected\n            in the menu.\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        filter: a [`Filter`](/slackblocks/latest/reference/objects/#objects.ConversationFilter)\n=======\n        filter: a [`Filter`](/slackblocks/reference/objects/#objects.ConversationFilter)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            object that filters out conversations that don't match the settings\n            of the filter.\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the menu when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_conversations: Optional[List[str]] = None,\n        default_to_current_conversation: Optional[bool] = False,\n        confirm: ConfirmationDialogue = None,\n        max_selected_items: Optional[int] = None,\n        filter: Optional[ConversationFilter] = None,\n        focus_on_load: Optional[bool] = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.MULTI_SELECT_CONVERSATIONS)\n        self.action_id = validate_action_id(action_id)\n        self.initial_conversations = coerce_to_list(\n            initial_conversations, str, allow_none=True\n        )\n        self.default_to_current_conversation = default_to_current_conversation\n        self.confirm = confirm\n        self.max_selected_items = max_selected_items\n        self.filter = filter\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, force_plaintext=True, max_length=150, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        conversation_multi_select = self._attributes()\n        conversation_multi_select[\"action_id\"] = self.action_id\n        if self.initial_conversations:\n            conversation_multi_select[\"intial_conversations\"] = (\n                self.initial_conversations\n            )\n        if self.default_to_current_conversation:\n            conversation_multi_select[\"default_to_current_conversation\"] = (\n                self.default_to_current_conversation\n            )\n        if self.confirm:\n            conversation_multi_select[\"confirm\"] = self.confirm._resolve()\n        if self.max_selected_items:\n            conversation_multi_select[\"max_selected_items\"] = self.max_selected_items\n        if self.filter:\n            conversation_multi_select[\"filter\"] = self.filter._resolve()\n        if self.focus_on_load:\n            conversation_multi_select[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            conversation_multi_select[\"placeholder\"] = self.placeholder._resolve()\n        return conversation_multi_select\n</code></pre>"},{"location":"reference/elements/#elements.ConversationSelectMenu","title":"ConversationSelectMenu","text":"<pre><code>A select menu interactive UI element, sourced with a list of public and private channels,\n    DMs, and MPIMs visible to the current user.\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#conversations_select&gt;.\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n    initial_conversation: the single (string) coversation ID that will be initially\n        selected when first presented to the user.\n    default_to_current_conversation: Pre-populates the select menu with the\n        conversation that the user was viewing when they opened the modal\n        (defaults to `False`).\n    confirm: a `ConfirmationDialogue` object that will be presented when an\n        option in the overflow menu is selected.\n    response_url_enabled: When set to true, the view_submission payload from the\n        menu's parent view will contain a response_url. (This response_url can be\n        used for message responses).\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         filter: a <code>Filter</code> =======         filter: a <code>Filter</code></p> <p>Stashed changes             object that filters out conversations that don't match the settings             of the filter.         focus_on_load: whether or not the input will be set to autofocus             within the view object.         placeholder: a plain-text <code>Text</code> object (max 150 chars) that shows             in the input when it's initially rendered.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class ConversationSelectMenu(Element):\n    \"\"\"\n    A select menu interactive UI element, sourced with a list of public and private channels,\n        DMs, and MPIMs visible to the current user.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#conversations_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_conversation: the single (string) coversation ID that will be initially\n            selected when first presented to the user.\n        default_to_current_conversation: Pre-populates the select menu with the\n            conversation that the user was viewing when they opened the modal\n            (defaults to `False`).\n        confirm: a `ConfirmationDialogue` object that will be presented when an\n            option in the overflow menu is selected.\n        response_url_enabled: When set to true, the view_submission payload from the\n            menu's parent view will contain a response_url. (This response_url can be\n            used for message responses).\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        filter: a [`Filter`](/slackblocks/latest/reference/objects/#objects.ConversationFilter)\n=======\n        filter: a [`Filter`](/slackblocks/reference/objects/#objects.ConversationFilter)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            object that filters out conversations that don't match the settings\n            of the filter.\n        focus_on_load: whether or not the input will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the input when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_conversation: Optional[str] = None,\n        default_to_current_conversation: Optional[bool] = False,\n        confirm: Optional[ConfirmationDialogue] = None,\n        response_url_enabled: Optional[bool] = False,\n        filter: Optional[ConversationFilter] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.CONVERSATIONS_SELECT_MENU)\n        self.action_id = validate_action_id(action_id)\n        self.initial_conversation = initial_conversation\n        self.default_to_current_conversation = default_to_current_conversation\n        self.confirm = confirm\n        self.response_url_enabled = response_url_enabled\n        self.filter = filter\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder,\n            max_length=150,\n            force_plaintext=True,\n            allow_none=True,\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        conversation_select_menu = self._attributes()\n        conversation_select_menu[\"action_id\"] = self.action_id\n        if self.initial_conversation:\n            conversation_select_menu[\"initial_conversation\"] = self.initial_conversation\n        if self.default_to_current_conversation:\n            conversation_select_menu[\"default_to_current_conversation\"] = (\n                self.default_to_current_conversation\n            )\n        if self.confirm:\n            conversation_select_menu[\"confirm\"] = self.confirm._resolve()\n        if self.response_url_enabled:\n            conversation_select_menu[\"response_url_enabled\"] = self.response_url_enabled\n        if self.filter:\n            conversation_select_menu[\"filter\"] = self.filter\n        if self.focus_on_load:\n            conversation_select_menu[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            conversation_select_menu[\"placeholder\"] = self.placeholder._resolve()\n        return conversation_select_menu\n</code></pre>"},{"location":"reference/elements/#elements.DatePicker","title":"DatePicker","text":"<p>Interactive element that allows users to select a date from a calendar.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#datepicker.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_date</code> <code>Optional[str]</code> <p>the date (in <code>YYYY-MM-DD</code> format) that will appear on the picker when it first renders.</p> <code>None</code> <code>confirm</code> <code>ConfirmationDialogue</code> <p>a <code>ConfirmationDialogue</code> object that will be presented when the date picker is clicked.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the date picker will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a <code>TextType.PLAINTEXT</code> <code>Text</code> object that defines what text will initially appear on the picker.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class DatePicker(Element):\n    \"\"\"\n    Interactive element that allows users to select a date from a calendar.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#datepicker&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_date: the date (in `YYYY-MM-DD` format) that will appear on the\n            picker when it first renders.\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the date picker is clicked.\n        focus_on_load: whether or not the date picker will be set to autofocus\n            within the view object.\n        placeholder: a `TextType.PLAINTEXT` `Text` object that defines what text\n            will initially appear on the picker.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_date: Optional[str] = None,\n        confirm: ConfirmationDialogue = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ) -&gt; \"DatePicker\":\n        super().__init__(type_=ElementType.DATE_PICKER)\n        self.action_id = validate_action_id(action_id)\n        if initial_date:\n            self.initial_date = datetime.strptime(initial_date, \"%Y-%m-%d\").strftime(\n                \"%Y-%m-%d\"\n            )\n        self.confirm = confirm\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, force_plaintext=True, max_length=150, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        date_picker = self._attributes()\n        date_picker[\"action_id\"] = self.action_id\n        if self.initial_date is not None:\n            date_picker[\"initial_date\"] = self.initial_date\n        if self.confirm:\n            date_picker[\"confirm\"] = self.confirm\n        if self.focus_on_load:\n            date_picker[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            date_picker[\"placeholder\"] = self.placeholder._resolve()\n        return date_picker\n</code></pre>"},{"location":"reference/elements/#elements.DateTimePicker","title":"DateTimePicker","text":"<p>Allows users to select both a date and a time of day.</p> <p>Provides the date-time formatted as a Unix timestamp.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#datetimepicker.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_datetime</code> <code>Optional[int]</code> <p>the initial value the date-time picker will be set to when it first renders.</p> <code>None</code> <code>confirm</code> <code>ConfirmationDialogue</code> <p>a <code>ConfirmationDialogue</code> object that will be presented when the button is date-time picker is used.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the datetime picker will be set to autofocus within the view object.</p> <code>False</code> <p>Throws:     InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class DateTimePicker(Element):\n    \"\"\"\n    Allows users to select both a date and a time of day.\n\n    Provides the date-time formatted as a Unix timestamp.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#datetimepicker&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_datetime: the initial value the date-time picker will be set to\n            when it first renders.\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the button is date-time picker is used.\n        focus_on_load: whether or not the datetime picker will be set to autofocus\n            within the view object.\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_datetime: Optional[int] = None,\n        confirm: ConfirmationDialogue = None,\n        focus_on_load: bool = False,\n    ) -&gt; \"DateTimePicker\":\n        super().__init__(type_=ElementType.DATETIME_PICKER)\n        self.action_id = validate_action_id(action_id)\n        if initial_datetime:\n            self.initial_datetime = initial_datetime\n        self.confirm = confirm\n        self.focus_on_load = focus_on_load\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        datetime_picker = self._attributes()\n        datetime_picker[\"action_id\"] = self.action_id\n        if self.initial_datetime:\n            datetime_picker[\"initial_date_time\"] = self.initial_datetime\n        if self.confirm:\n            datetime_picker[\"confirm\"] = self.confirm\n        if self.focus_on_load:\n            datetime_picker[\"focus_on_load\"] = self.focus_on_load\n        return datetime_picker\n</code></pre>"},{"location":"reference/elements/#elements.EmailInput","title":"EmailInput","text":"<p>Allows user to enter an email into a single-line text field.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#email.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_value</code> <code>Optional[str]</code> <p>The initial value in the email input when it is loaded.</p> <code>None</code> <code>dispatch_action_config</code> <code>Optional[DispatchActionConfiguration]</code> <p>a <code>DispatchActionConfiguration</code> object that determines when during text input the element returns a <code>block_actions</code> payload.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the email input will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a <code>TextType.PLAINTEXT</code> <code>Text</code> object that defines what text will initially appear in the input field.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class EmailInput(Element):\n    \"\"\"\n    Allows user to enter an email into a single-line text field.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#email&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_value: The initial value in the email input when it is loaded.\n        dispatch_action_config: a `DispatchActionConfiguration` object that\n            determines when during text input the element returns a\n            `block_actions` payload.\n        focus_on_load: whether or not the email input will be set to autofocus\n            within the view object.\n        placeholder: a `TextType.PLAINTEXT` `Text` object that defines what text\n            will initially appear in the input field.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_value: Optional[str] = None,\n        dispatch_action_config: Optional[DispatchActionConfiguration] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.EMAIL_INPUT)\n        self.action_id = validate_action_id(action_id)\n        self.initial_value = initial_value\n        self.dispatch_action_config = dispatch_action_config\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, max_length=150, force_plaintext=True, allow_none=True\n        )\n\n    def _resolve(self):\n        email_input = self._attributes()\n        email_input[\"action_id\"] = self.action_id\n        if self.initial_value:\n            email_input[\"initial_value\"] = self.initial_value\n        if self.dispatch_action_config:\n            email_input[\"dispatch_action_config\"] = (\n                self.dispatch_action_config._resolve()\n            )\n        if self.focus_on_load:\n            email_input[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            email_input[\"placeholder\"] = self.placeholder._resolve()\n        return email_input\n</code></pre>"},{"location":"reference/elements/#elements.ExternalMultiSelectMenu","title":"ExternalMultiSelectMenu","text":"<pre><code>An interactive UI element that loads its options from an external data source,\n    allowing for a dynamic list of options.\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#external_multi_select&gt;.\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n    min_query_length: minimum number of characters entered before the query\n        is dispactched (defaults to 3 if not provided).\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         initial_options: the <code>Options</code> =======         initial_options: the <code>Options</code></p> <p>Stashed changes             to be intially selected when the element is first rendered.         confirm: a <code>ConfirmationDialogue</code> object that will be presented when             the menu is used.         max_selected_items: the highest number of items from the list that             can be selected at one time.         focus_on_load: whether or not the menu will be set to autofocus             within the view object.         placeholder: a plain-text <code>Text</code> object (max 150 chars) that shows             in the menu when it's initially rendered.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class ExternalMultiSelectMenu(Element):\n    \"\"\"\n    An interactive UI element that loads its options from an external data source,\n        allowing for a dynamic list of options.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#external_multi_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        min_query_length: minimum number of characters entered before the query\n            is dispactched (defaults to 3 if not provided).\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        initial_options: the [`Options`](/slackblocks/latest/reference/objects/#objects.Option)\n=======\n        initial_options: the [`Options`](/slackblocks/reference/objects/#objects.Option)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            to be intially selected when the element is first rendered.\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the menu is used.\n        max_selected_items: the highest number of items from the list that\n            can be selected at one time.\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the menu when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        min_query_length: Optional[int] = None,\n        initial_options: Optional[\n            Union[Option, List[Option], OptionGroup, List[OptionGroup]]\n        ] = None,\n        confirm: ConfirmationDialogue = None,\n        max_selected_items: Optional[int] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.MULTI_SELECT_EXTERNAL)\n        self.action_id = validate_action_id(action_id)\n        self.min_query_length = min_query_length\n        self.initial_options = coerce_to_list(\n            initial_options, class_=(Option, OptionGroup), allow_none=True, max_size=100\n        )\n        self.confirm = confirm\n        self.max_selected_items = max_selected_items\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, force_plaintext=True, max_length=150, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        external_select_menu = self._attributes()\n        external_select_menu[\"action_id\"] = self.action_id\n        if self.min_query_length:\n            external_select_menu[\"min_query_length\"] = self.min_query_length\n        if self.initial_options:\n            external_select_menu[\"initial_options\"] = [\n                initial_option._resolve() for initial_option in self.initial_options\n            ]\n        if self.confirm:\n            external_select_menu[\"confirm\"] = self.confirm._resolve()\n        if self.max_selected_items:\n            external_select_menu[\"max_selected_items\"] = self.max_selected_items\n        if self.focus_on_load:\n            external_select_menu[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            external_select_menu[\"placeholder\"] = self.placeholder._resolve()\n        return external_select_menu\n</code></pre>"},{"location":"reference/elements/#elements.ExternalSelectMenu","title":"ExternalSelectMenu","text":"<pre><code>A select menu interactive UI element, sourced with externally provided options.\n\nSee:\n    &lt;https://api.slack.com/slackblocks/latest/reference/block-kit/block-elements#external_select&gt;. # noqa: E501\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n    initial_option: an\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream             <code>Option</code> object that will be =======             <code>Option</code> object that will be</p> <p>Stashed changes             initially selected when first presented to the user.         min_query_length: minimum number of characters entered before the query             is dispactched (defaults to 3 if not provided).         confirm: a <code>ConfirmationDialogue</code> object that will be presented when an             option in the overflow menu is selected.         focus_on_load: whether or not the input will be set to autofocus             within the view object.         placeholder: a plain-text <code>Text</code> object (max 150 chars) that shows             in the input when it's initially rendered.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class ExternalSelectMenu(Element):\n    \"\"\"\n    A select menu interactive UI element, sourced with externally provided options.\n\n    See:\n        &lt;https://api.slack.com/slackblocks/latest/reference/block-kit/block-elements#external_select&gt;. # noqa: E501\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_option: an\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n            [`Option`](/slackblocks/latest/reference/objects/#objects.Option) object that will be\n=======\n            [`Option`](/slackblocks/reference/objects/#objects.Option) object that will be\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            initially selected when first presented to the user.\n        min_query_length: minimum number of characters entered before the query\n            is dispactched (defaults to 3 if not provided).\n        confirm: a `ConfirmationDialogue` object that will be presented when an\n            option in the overflow menu is selected.\n        focus_on_load: whether or not the input will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the input when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_option: Union[Option, OptionGroup] = None,\n        min_query_length: Optional[int] = None,\n        confirm: Optional[ConfirmationDialogue] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.EXTERNAL_SELECT_MENU)\n        self.action_id = validate_action_id(action_id)\n        self.initial_option = initial_option\n        self.min_query_length = min_query_length\n        self.confirm = confirm\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder,\n            max_length=150,\n            force_plaintext=True,\n            allow_none=True,\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        external_select_menu = self._attributes()\n        external_select_menu[\"action_id\"] = self.action_id\n        if self.initial_option:\n            external_select_menu[\"initial_option\"] = self.initial_option._resolve()\n        if self.min_query_length is not None:\n            external_select_menu[\"min_query_length\"] = self.min_query_length\n        if self.confirm:\n            external_select_menu[\"confirm\"] = self.confirm._resolve()\n        if self.focus_on_load:\n            external_select_menu[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            external_select_menu[\"placeholder\"] = self.placeholder._resolve()\n        return external_select_menu\n</code></pre>"},{"location":"reference/elements/#elements.FileInput","title":"FileInput","text":"<p>An interactive element that allows users to upload files.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#file_input.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>Optional[str]</code> <p>an identifier so the source of the action can be known.</p> <code>None</code> <code>filetypes</code> <code>Optional[Union[str, List[str]]]</code> <p>a list of file extensions (as strings) that will be accepted for upload.</p> <code>None</code> <code>max_files</code> <code>Optional[int]</code> <p>the maximum number of files that can be uploaded (between 1 and 10).</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class FileInput(Element):\n    \"\"\"\n    An interactive element that allows users to upload files.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#file_input&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        filetypes: a list of file extensions (as strings) that will be accepted\n            for upload.\n        max_files: the maximum number of files that can be uploaded (between 1\n            and 10).\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: Optional[str] = None,\n        filetypes: Optional[Union[str, List[str]]] = None,\n        max_files: Optional[int] = None,\n    ) -&gt; \"FileInput\":\n        super().__init__(ElementType.FILE_INPUT)\n        self.action_id = validate_action_id(action_id)\n        self.filetypes = coerce_to_list(\n            filetypes,\n            (str),\n            allow_none=True,\n        )\n        self.max_files = validate_int(\n            max_files, min_value=1, max_value=10, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        file_input = super()._resolve()\n        if self.action_id is not None:\n            file_input[\"action_id\"] = self.action_id\n        if self.filetypes is not None:\n            file_input[\"filetypes\"] = self.filetypes\n        if self.max_files is not None:\n            file_input[\"max_files\"] = self.max_files\n        return file_input\n</code></pre>"},{"location":"reference/elements/#elements.Image","title":"Image","text":"<pre><code>An element to insert an image - this element can be used in section\nand context blocks only. If you want a block with only an image in it,\nyou're looking for the Image block.\n\nYou must provide either one of `image_url` or `slack_file`\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#image&gt;.\n\nArgs:\n    alt_text: a plain-text-only summary of the content of the image.\n    image_url: a URL for a publicly hosted image (the user must provide\n        either `image_url` or `slack_file`).\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         slack_file: a             <code>SlackFile</code> =======         slack_file: a <code>SlackFile</code></p> <p>Stashed changes             (the user must provide either <code>image_url</code> or <code>slack_file</code>).</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation,\n        or both/neither of `image_url` and `slack_file` are provided.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class Image(Element):\n    \"\"\"\n    An element to insert an image - this element can be used in section\n    and context blocks only. If you want a block with only an image in it,\n    you're looking for the Image block.\n\n    You must provide either one of `image_url` or `slack_file`\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#image&gt;.\n\n    Args:\n        alt_text: a plain-text-only summary of the content of the image.\n        image_url: a URL for a publicly hosted image (the user must provide\n            either `image_url` or `slack_file`).\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        slack_file: a\n            [`SlackFile`](/slackblocks/latest/reference/objects/#objects.SlackFile)\n=======\n        slack_file: a [`SlackFile`](/slackblocks/reference/objects/#objects.SlackFile)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            (the user must provide either `image_url` or `slack_file`).\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation,\n            or both/neither of `image_url` and `slack_file` are provided.\n    \"\"\"\n\n    def __init__(\n        self,\n        alt_text: str = \" \",\n        image_url: Optional[str] = None,\n        slack_file: Optional[SlackFile] = None,\n    ):\n        super().__init__(type_=ElementType.IMAGE)\n        if image_url is None and slack_file is None:\n            raise InvalidUsageError(\"Must provide one of `image_url` or `slack_file`\")\n        if image_url and slack_file:\n            raise InvalidUsageError(\"Cannot provide both `image_url` or `slack_file`\")\n        self.image_url = image_url\n        self.alt_text = alt_text\n        self.slack_file = slack_file\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        image = self._attributes()\n        if self.image_url is not None:\n            image[\"image_url\"] = self.image_url\n        image[\"alt_text\"] = self.alt_text\n        if self.slack_file is not None:\n            image[\"slack_file\"] = self.slack_file\n        return image\n</code></pre>"},{"location":"reference/elements/#elements.NumberInput","title":"NumberInput","text":"<p>This input elements accepts both integer and decimal numbers. For example, 0.25, 5.5, and -10 are all valid input values.</p> <p>See https://api.slack.com/reference/block-kit/block-elements#number.</p> <p>Parameters:</p> Name Type Description Default <code>is_decimal_allowed</code> <code>bool</code> <p>whether to accept decimal values as input.</p> required <code>action_id</code> <code>Optional[str]</code> <p>an identifier so the source of the action can be known.</p> <code>None</code> <code>initial_value</code> <code>Optional[str]</code> <p>the initial value in the number input when it is loaded.</p> <code>None</code> <code>min_value</code> <code>Optional[Union[float, int]]</code> <p>minimum accepted value for the input field.</p> <code>None</code> <code>max_value</code> <code>Optional[Union[float, int]]</code> <p>maximum accepted value for the input field.</p> <code>None</code> <code>dispatch_action_config</code> <code>Optional[DispatchActionConfiguration]</code> <p>a <code>DispatchActionConfiguration</code> object that determines when during text input the element returns a <code>block_actions</code> payload.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the menu will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the input when it's initially rendered.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class NumberInput(Element):\n    \"\"\"\n    This input elements accepts both integer and decimal numbers. For example,\n    0.25, 5.5, and -10 are all valid input values.\n\n    See &lt;https://api.slack.com/reference/block-kit/block-elements#number&gt;.\n\n    Args:\n        is_decimal_allowed: whether to accept decimal values as input.\n        action_id: an identifier so the source of the action can be known.\n        initial_value: the initial value in the number input when it is loaded.\n        min_value: minimum accepted value for the input field.\n        max_value: maximum accepted value for the input field.\n        dispatch_action_config: a `DispatchActionConfiguration` object that\n            determines when during text input the element returns a\n            `block_actions` payload.\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the input when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        is_decimal_allowed: bool,\n        action_id: Optional[str] = None,\n        initial_value: Optional[str] = None,\n        min_value: Optional[Union[float, int]] = None,\n        max_value: Optional[Union[float, int]] = None,\n        dispatch_action_config: Optional[DispatchActionConfiguration] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.NUMBER_INPUT)\n        self.is_decimal_allowed = is_decimal_allowed\n        self.action_id = validate_action_id(action_id, allow_none=True)\n        self.initial_value = initial_value\n        self.min_value = min_value\n        self.max_value = max_value\n        if min_value:\n            if not is_decimal_allowed:\n                if isinstance(min_value, float):\n                    raise InvalidUsageError(\n                        f\"`min_value` ({min_value}) cannot be a float when \"\n                        \"`is_decimal_allowed` is `False`\"\n                    )\n        if max_value:\n            if not is_decimal_allowed:\n                if isinstance(max_value, float):\n                    raise InvalidUsageError(\n                        f\"`max_value` ({max_value}) cannot be a float when \"\n                        \"`is_decimal_allowed` is `False`\"\n                    )\n        if (min_value or min_value == 0) and (max_value or max_value == 0):\n            if min_value &gt; max_value:\n                raise InvalidUsageError(\n                    f\"`min_value` ({min_value}) cannot be greater than \"\n                    \"`max_value` ({min_value})\"\n                )\n        self.dispatch_action_config = dispatch_action_config\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, max_length=150, force_plaintext=True, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        number_input = self._attributes()\n        number_input[\"is_decimal_allowed\"] = self.is_decimal_allowed\n        if self.action_id:\n            number_input[\"action_id\"] = self.action_id\n        if self.initial_value:\n            number_input[\"initial_value\"] = self.initial_value\n        if self.min_value:\n            number_input[\"min_value\"] = self.min_value\n        if self.max_value:\n            number_input[\"max_value\"] = self.max_value\n        if self.dispatch_action_config:\n            number_input[\"dispatch_action_config\"] = (\n                self.dispatch_action_config._resolve()\n            )\n        if self.focus_on_load:\n            number_input[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            number_input[\"placeholder\"] = self.placeholder._resolve()\n        return number_input\n</code></pre>"},{"location":"reference/elements/#elements.OverflowMenu","title":"OverflowMenu","text":"<pre><code>Context menu for additional options (think '...').\n\nSee &lt;https://api.slack.com/reference/block-kit/block-elements#overflow&gt;.\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n    options: a list of\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream             <code>Option</code> objects that will form =======             <code>Option</code> objects that will form</p> <p>Stashed changes             the content of the overflow menu.         confirm: a <code>ConfirmationDialogue</code> object that will be presented when an             option in the overflow menu is selected.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class OverflowMenu(Element):\n    \"\"\"\n    Context menu for additional options (think '...').\n\n    See &lt;https://api.slack.com/reference/block-kit/block-elements#overflow&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        options: a list of\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n            [`Option`](/slackblocks/latest/reference/objects/#objects.Option) objects that will form\n=======\n            [`Option`](/slackblocks/reference/objects/#objects.Option) objects that will form\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            the content of the overflow menu.\n        confirm: a `ConfirmationDialogue` object that will be presented when an\n            option in the overflow menu is selected.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        options: Union[Option, List[Option]],\n        confirm: ConfirmationDialogue = None,\n    ):\n        super().__init__(type_=ElementType.OVERFLOW_MENU)\n        self.action_id = validate_action_id(action_id)\n        self.options = coerce_to_list(options, Option, min_size=1, max_size=5)\n        self.confirm = confirm\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        overflow_menu = self._attributes()\n        overflow_menu[\"action_id\"] = self.action_id\n        overflow_menu[\"options\"] = [option._resolve() for option in self.options]\n        if self.confirm:\n            overflow_menu[\"confirm\"] = self.confirm._resolve()\n        return overflow_menu\n</code></pre>"},{"location":"reference/elements/#elements.PlainTextInput","title":"PlainTextInput","text":"<p>A plain-text input, similar to the HTML  tag, creates a field where a user can enter freeform data. It can appear as a single-line field or a larger text area using the multiline flag.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#input.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_value</code> <code>Optional[str]</code> <p>the initial value in the plain-text input when it is loaded.</p> <code>None</code> <code>multiline</code> <code>bool</code> <p>whether to accept multiple lines of input(defaults to false).</p> <code>False</code> <code>min_length</code> <code>Optional[int]</code> <p>minimum number of characters to accept as input.</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>maximum number of characters to accept as input.</p> <code>None</code> <code>dispatch_action_config</code> <code>Optional[DispatchActionConfiguration]</code> <p>a <code>DispatchActionConfiguration</code> object that determines when during text input the element returns a <code>block_actions</code> payload.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the input will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the input when it's initially rendered.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class PlainTextInput(Element):\n    \"\"\"\n    A plain-text input, similar to the HTML &lt;input&gt; tag, creates a field where a user\n    can enter freeform data. It can appear as a single-line field or a larger text\n    area using the multiline flag.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#input&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_value: the initial value in the plain-text input when it is loaded.\n        multiline: whether to accept multiple lines of input(defaults to false).\n        min_length: minimum number of characters to accept as input.\n        max_length: maximum number of characters to accept as input.\n        dispatch_action_config: a `DispatchActionConfiguration` object that\n            determines when during text input the element returns a\n            `block_actions` payload.\n        focus_on_load: whether or not the input will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the input when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_value: Optional[str] = None,\n        multiline: bool = False,\n        min_length: Optional[int] = None,\n        max_length: Optional[int] = None,\n        dispatch_action_config: Optional[DispatchActionConfiguration] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.PLAIN_TEXT_INPUT)\n        self.action_id = validate_action_id(action_id)\n        self.multiline = multiline\n        self.initial_value = initial_value\n        self.min_length = min_length\n        if max_length and max_length &gt; 3000:\n            raise InvalidUsageError(\"`max_length` value cannot exceed 3000 characters\")\n        self.max_length = max_length\n        self.dispatch_action_config = dispatch_action_config\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, max_length=150, force_plaintext=True, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        plain_text_input = self._attributes()\n        if self.multiline:\n            plain_text_input[\"multiline\"] = self.multiline\n        if self.action_id:\n            plain_text_input[\"action_id\"] = self.action_id\n        if self.initial_value:\n            plain_text_input[\"initial_value\"] = self.initial_value\n        if self.min_length:\n            plain_text_input[\"min_length\"] = self.min_length\n        if self.max_length:\n            plain_text_input[\"max_length\"] = self.max_length\n        if self.dispatch_action_config:\n            plain_text_input[\"dispatch_action_config\"] = (\n                self.dispatch_action_config._resolve()\n            )\n        if self.focus_on_load:\n            plain_text_input[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            plain_text_input[\"placeholder\"] = self.placeholder._resolve()\n        return plain_text_input\n</code></pre>"},{"location":"reference/elements/#elements.RadioButtonGroup","title":"RadioButtonGroup","text":"<pre><code>A radio button group that allows a user to choose one item from a list of possible options.\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#radio&gt;.\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n    options: a list of\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream             <code>Option</code> objects that will form             the content of the radio button group.         initial_option: an             <code>Option</code> object that will be =======             <code>Option</code> objects that will form             the content of the radio button group.         initial_option: an             <code>Option</code> object that will be</p> <p>Stashed changes             initially selected when first presented to the user.         confirm: a <code>ConfirmationDialogue</code> object that will be presented when an             option in the overflow menu is selected.         focus_on_load: whether or not the input will be set to autofocus             within the view object.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class RadioButtonGroup(Element):\n    \"\"\"\n    A radio button group that allows a user to choose one item from a list of possible options.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#radio&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        options: a list of\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n            [`Option`](/slackblocks/latest/reference/objects/#objects.Option) objects that will form\n            the content of the radio button group.\n        initial_option: an\n            [`Option`](/slackblocks/latest/reference/objects/#objects.Option) object that will be\n=======\n            [`Option`](/slackblocks/reference/objects/#objects.Option) objects that will form\n            the content of the radio button group.\n        initial_option: an\n            [`Option`](/slackblocks/reference/objects/#objects.Option) object that will be\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            initially selected when first presented to the user.\n        confirm: a `ConfirmationDialogue` object that will be presented when an\n            option in the overflow menu is selected.\n        focus_on_load: whether or not the input will be set to autofocus\n            within the view object.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        options: List[Option],\n        initial_option: Optional[Option] = None,\n        confirm: Optional[ConfirmationDialogue] = None,\n        focus_on_load: bool = False,\n    ):\n        super().__init__(type_=ElementType.RADIO_BUTTON_GROUP)\n        self.action_id = validate_action_id(action_id)\n        if len(options) &lt; 1 or len(options) &gt; 10:\n            raise InvalidUsageError(\n                \"Number of options to RadioButtonGroup must be between 1 and 10 (inclusive).\"\n            )\n        self.options = coerce_to_list(options, class_=Option, allow_none=False)\n        if initial_option is not None and initial_option not in options:\n            raise InvalidUsageError(\"`initial_option` must be a member of `options`\")\n        self.initial_option = initial_option\n        self.confirm = confirm\n        self.focus_on_load = focus_on_load\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        radio_button_group = self._attributes()\n        radio_button_group[\"action_id\"] = self.action_id\n        radio_button_group[\"options\"] = [option._resolve() for option in self.options]\n        if self.initial_option:\n            radio_button_group[\"initial_option\"] = self.initial_option._resolve()\n        if self.confirm:\n            radio_button_group[\"confirm\"] = self.confirm._resolve()\n        if self.focus_on_load:\n            radio_button_group[\"focus_on_load\"] = self.focus_on_load\n        return radio_button_group\n</code></pre>"},{"location":"reference/elements/#elements.RichTextInput","title":"RichTextInput","text":"<p>Allows users to enter formatted text in a WYSIWYG editor, similar to the Slack     messaging experience.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#rich_text_input.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_value</code> <code>Optional[RichText]</code> <p>The initial value in the rich text input when it is loaded.</p> <code>None</code> <code>dispatch_action_config</code> <code>Optional[DispatchActionConfiguration]</code> <p>a <code>DispatchActionConfiguration</code> object that determines when during text input the element returns a <code>block_actions</code> payload.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the menu will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the menu when it's initially rendered.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class RichTextInput(Element):\n    \"\"\"\n    Allows users to enter formatted text in a WYSIWYG editor, similar to the Slack\n        messaging experience.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#rich_text_input&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_value: The initial value in the rich text input when it is loaded.\n        dispatch_action_config: a `DispatchActionConfiguration` object that\n            determines when during text input the element returns a\n            `block_actions` payload.\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the menu when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_value: Optional[RichText] = None,\n        dispatch_action_config: Optional[DispatchActionConfiguration] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ) -&gt; \"RichTextInput\":\n        super().__init__(ElementType.RICH_TEXT_INPUT)\n        self.action_id = validate_action_id(action_id)\n        self.initial_value = initial_value\n        self.dispatch_action_config = dispatch_action_config\n        self.focus_on_load = focus_on_load\n        self.placeholder = placeholder\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        rich_text_input = super()._attributes()\n        rich_text_input[\"action_id\"] = self.action_id\n        if self.initial_value is not None:\n            rich_text_input[\"initial_value\"] = self.initial_value._resolve()\n        if self.dispatch_action_config is not None:\n            rich_text_input[\"dispatch_action_config\"] = self.dispatch_action_config\n        if self.focus_on_load is not None:\n            rich_text_input[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder is not None:\n            rich_text_input[\"placeholder\"] = self.placeholder\n        return rich_text_input\n</code></pre>"},{"location":"reference/elements/#elements.StaticMultiSelectMenu","title":"StaticMultiSelectMenu","text":"<pre><code>The most basic form of select menu containing a static list of options\npassed in when defining the element.\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#static_multi_select&gt;.\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         options: a list of <code>Options</code>             (max 100). Only one of <code>options</code> or <code>option_groups</code> must be             provided.         option_groups: a list of             <code>OptionGroups</code>             (max 100). Only one of <code>options</code> or <code>option_groups</code> can be             provided.         initial_options: the <code>Options</code> =======         options: a list of <code>Options</code>             (max 100). Only one of <code>options</code> or <code>option_groups</code> must be             provided.         option_groups: a list of             <code>OptionGroups</code>             (max 100). Only one of <code>options</code> or <code>option_groups</code> can be             provided.         initial_options: the <code>Options</code></p> <p>Stashed changes             to be intially selected when the element is first rendered.         confirm: a <code>ConfirmationDialogue</code> object that will be presented when             the menu is used.         max_selected_items: the         focus_on_load: whether or not the menu will be set to autofocus             within the view object.         placeholder: a plain-text <code>Text</code> object (max 150 chars) that shows             in the menu when it's initially rendered.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class StaticMultiSelectMenu(Element):\n    \"\"\"\n    The most basic form of select menu containing a static list of options\n    passed in when defining the element.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#static_multi_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        options: a list of [`Options`](/slackblocks/latest/reference/objects/#objects.Option)\n            (max 100). Only one of `options` or `option_groups` must be\n            provided.\n        option_groups: a list of\n            [`OptionGroups`](/slackblocks/latest/reference/objects/#objects.OptionGroup)\n            (max 100). Only one of `options` or `option_groups` can be\n            provided.\n        initial_options: the [`Options`](/slackblocks/latest/reference/objects/#objects.Option)\n=======\n        options: a list of [`Options`](/slackblocks/reference/objects/#objects.Option)\n            (max 100). Only one of `options` or `option_groups` must be\n            provided.\n        option_groups: a list of\n            [`OptionGroups`](/slackblocks/reference/objects/#objects.OptionGroup)\n            (max 100). Only one of `options` or `option_groups` can be\n            provided.\n        initial_options: the [`Options`](/slackblocks/reference/objects/#objects.Option)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            to be intially selected when the element is first rendered.\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the menu is used.\n        max_selected_items: the\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the menu when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        options: Union[Option, List[Option]],\n        option_groups: List[OptionGroup] = None,\n        initial_options: Optional[\n            Union[Option, List[Option], OptionGroup, List[OptionGroup]]\n        ] = None,\n        confirm: ConfirmationDialogue = None,\n        max_selected_items: Optional[int] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.MULTI_SELECT_STATIC)\n        self.action_id = validate_action_id(action_id)\n        if options and option_groups:\n            raise InvalidUsageError(\n                \"Cannot set both `options` and `option_groups` parameters.\"\n            )\n        self.options = coerce_to_list(\n            options, class_=Option, allow_none=True, max_size=100\n        )\n        self.option_groups = coerce_to_list(\n            option_groups, class_=OptionGroup, allow_none=True, max_size=100\n        )\n        self.initial_options = coerce_to_list(\n            initial_options, class_=(Option, OptionGroup), allow_none=True, max_size=100\n        )\n        if (\n            options\n            and self.initial_options\n            and not all(isinstance(option, Option) for option in self.initial_options)\n        ):\n            raise InvalidUsageError(\n                \"If using `options` then `initial_options` must also be of type `List[Option]`, \"\n                f\"not `{type(self.initial_options)}`.\"\n            )\n        if (\n            option_groups\n            and self.initial_options\n            and not all(\n                isinstance(option, OptionGroup) for option in self.initial_options\n            )\n        ):\n            raise InvalidUsageError(\n                \"If using `option_groups` then `initial_options` must also be of type \"\n                f\"`List[OptionGroup]`, not `{type(self.initial_options)}`.\"\n            )\n\n        # Check that Option Text is all TextType.PLAINTEXT\n        if self.options:\n            options_to_validate = self.options\n        if self.option_groups:\n            options_to_validate = sum(\n                [option_group.options for option_group in option_groups], []\n            )\n        for option in options_to_validate:\n            if option.text.text_type == TextType.MARKDOWN:\n                raise InvalidUsageError(\n                    \"Text in Options for StaticSelectMenu can only be of TextType.PLAINTEXT\"\n                )\n\n        self.confirm = confirm\n        self.max_selected_items = max_selected_items\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, force_plaintext=True, max_length=150, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        static_multi_select = self._attributes()\n        static_multi_select[\"action_id\"] = self.action_id\n        if self.options:\n            static_multi_select[\"options\"] = [\n                option._resolve() for option in self.options\n            ]\n        if self.option_groups:\n            static_multi_select[\"option_groups\"] = [\n                option_group._resolve() for option_group in self.option_groups\n            ]\n        if self.initial_options:\n            static_multi_select[\"initial_options\"] = [\n                initial_option._resolve() for initial_option in self.initial_options\n            ]\n        if self.confirm:\n            static_multi_select[\"confirm\"] = self.confirm._resolve()\n        if self.max_selected_items:\n            static_multi_select[\"max_selected_items\"] = self.max_selected_items\n        if self.focus_on_load:\n            static_multi_select[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            static_multi_select[\"placeholder\"] = self.placeholder._resolve()\n        return static_multi_select\n</code></pre>"},{"location":"reference/elements/#elements.StaticSelectMenu","title":"StaticSelectMenu","text":"<pre><code>A simple select menu interactive UI element, with a static list of options passed in when\n    defining the element.\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#static_select&gt;.\n\nArgs:\n    action_id: an identifier so the source of the action can be known.\n    options: a list of\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream             <code>Option</code> objects that will form             the content of the menu (max 100).         option_groups: a list of             <code>OptionGroups</code>             (max 100). Only one of <code>options</code> or <code>option_groups</code> can be             provided.         initial_option: an             <code>Option</code> object that will be =======             <code>Option</code> objects that will form             the content of the menu (max 100).         option_groups: a list of             <code>OptionGroups</code>             (max 100). Only one of <code>options</code> or <code>option_groups</code> can be             provided.         initial_option: an             <code>Option</code> object that will be</p> <p>Stashed changes             initially selected when first presented to the user.         confirm: a <code>ConfirmationDialogue</code> object that will be presented when an             option in the overflow menu is selected.         focus_on_load: whether or not the input will be set to autofocus             within the view object.         placeholder: a plain-text <code>Text</code> object (max 150 chars) that shows             in the input when it's initially rendered.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class StaticSelectMenu(Element):\n    \"\"\"\n    A simple select menu interactive UI element, with a static list of options passed in when\n        defining the element.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#static_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        options: a list of\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n            [`Option`](/slackblocks/latest/reference/objects/#objects.Option) objects that will form\n            the content of the menu (max 100).\n        option_groups: a list of\n            [`OptionGroups`](/slackblocks/latest/reference/objects/#objects.OptionGroup)\n            (max 100). Only one of `options` or `option_groups` can be\n            provided.\n        initial_option: an\n            [`Option`](/slackblocks/latest/reference/objects/#objects.Option) object that will be\n=======\n            [`Option`](/slackblocks/reference/objects/#objects.Option) objects that will form\n            the content of the menu (max 100).\n        option_groups: a list of\n            [`OptionGroups`](/slackblocks/reference/objects/#objects.OptionGroup)\n            (max 100). Only one of `options` or `option_groups` can be\n            provided.\n        initial_option: an\n            [`Option`](/slackblocks/reference/objects/#objects.Option) object that will be\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            initially selected when first presented to the user.\n        confirm: a `ConfirmationDialogue` object that will be presented when an\n            option in the overflow menu is selected.\n        focus_on_load: whether or not the input will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the input when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        options: List[Option] = None,\n        option_groups: List[OptionGroup] = None,\n        initial_option: Optional[Union[Option, OptionGroup]] = None,\n        confirm: Optional[ConfirmationDialogue] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.STATIC_SELECT_MENU)\n        self.action_id = validate_action_id(action_id)\n        if options and option_groups:\n            raise InvalidUsageError(\n                \"Cannot set both `options` and `option_groups` parameters.\"\n            )\n        self.options = coerce_to_list(\n            options, class_=Option, allow_none=True, max_size=100\n        )\n        self.option_groups = coerce_to_list(\n            option_groups, class_=OptionGroup, allow_none=True, max_size=100\n        )\n        if options and initial_option and not isinstance(initial_option, Option):\n            raise InvalidUsageError(\n                \"If using `options` then `initial_option` must also be of type `Option`, \"\n                f\"not `{type(initial_option)}`.\"\n            )\n        if (\n            option_groups\n            and initial_option\n            and not isinstance(initial_option, OptionGroup)\n        ):\n            raise InvalidUsageError(\n                \"If using `option_groups` then `initial_option` must also be of type \"\n                f\"`OptionGroup`, not `{type(initial_option)}`.\"\n            )\n\n        # Check that Option Text is all TextType.PLAINTEXT\n        if self.options:\n            options_to_validate = self.options\n        if self.option_groups:\n            options_to_validate = sum(\n                [option_group.options for option_group in option_groups], []\n            )\n        for option in options_to_validate:\n            if option.text.text_type == TextType.MARKDOWN:\n                raise InvalidUsageError(\n                    \"Text in Options for StaticSelectMenu can only be of TextType.PLAINTEXT\"\n                )\n\n        self.initial_option = initial_option\n        self.confirm = confirm\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, max_length=150, force_plaintext=True, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        static_select_menu = self._attributes()\n        static_select_menu[\"action_id\"] = self.action_id\n        if self.options:\n            static_select_menu[\"options\"] = [\n                option._resolve() for option in self.options\n            ]\n        if self.option_groups:\n            static_select_menu[\"option_groups\"] = [\n                option_group._resolve() for option_group in self.option_groups\n            ]\n        if self.initial_option:\n            static_select_menu[\"initial_option\"] = self.initial_option._resolve()\n        if self.confirm:\n            static_select_menu[\"confirm\"] = self.confirm._resolve()\n        if self.focus_on_load:\n            static_select_menu[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            static_select_menu[\"placeholder\"] = self.placeholder._resolve()\n        return static_select_menu\n</code></pre>"},{"location":"reference/elements/#elements.TimePicker","title":"TimePicker","text":"<p>An interactive UI element that allows users to select a time of day.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#timepicker.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_time</code> <code>Optional[str]</code> <code>None</code> <code>confirm</code> <code>Optional[ConfirmationDialogue]</code> <p>a <code>ConfirmationDialogue</code> object that will be presented when the input field is used.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the menu will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the menu when it's initially rendered.</p> <code>None</code> <code>timezone</code> <code>Optional[str]</code> <p>a string in the IANA format, e.g. \"America/Chicago\".</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class TimePicker(Element):\n    \"\"\"\n    An interactive UI element that allows users to select a time of day.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#timepicker&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_time:\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the input field is used.\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the menu when it's initially rendered.\n        timezone: a string in the IANA format, e.g. \"America/Chicago\".\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_time: Optional[str] = None,\n        confirm: Optional[ConfirmationDialogue] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n        timezone: Optional[str] = None,\n    ):\n        super().__init__(type_=ElementType.TIME_PICKER)\n        self.action_id = validate_action_id(action_id)\n        self.initial_time = initial_time\n        self.confirm = confirm\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder,\n            max_length=150,\n            force_plaintext=True,\n            allow_none=True,\n        )\n        self.timezone = timezone\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        time_picker = self._attributes()\n        time_picker[\"action_id\"] = self.action_id\n        if self.initial_time:\n            time_picker[\"initial_time\"] = self.initial_time\n        if self.confirm:\n            time_picker[\"confirm\"] = self.confirm\n        if self.focus_on_load:\n            time_picker[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            time_picker[\"placeholder\"] = self.placeholder._resolve()\n        if self.timezone is not None:\n            time_picker[\"timezone\"] = self.timezone\n        return time_picker\n</code></pre>"},{"location":"reference/elements/#elements.URLInput","title":"URLInput","text":"<p>An interactive UI element for collecting URL input from users.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#url.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_value</code> <code>Optional[str]</code> <p>the text to populate the input field with when it is first rendered.</p> <code>None</code> <code>dispatch_action_config</code> <code>Optional[DispatchActionConfiguration]</code> <p>a <code>DispatchActionConfiguration</code> object that determines when during text input the element returns a <code>block_actions</code> payload.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the menu will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the input when it's initially rendered.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class URLInput(Element):\n    \"\"\"\n    An interactive UI element for collecting URL input from users.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#url&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_value: the text to populate the input field with when it\n            is first rendered.\n        dispatch_action_config: a `DispatchActionConfiguration` object that\n            determines when during text input the element returns a\n            `block_actions` payload.\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the input when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_value: Optional[str] = None,\n        dispatch_action_config: Optional[DispatchActionConfiguration] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.URL_INPUT)\n        self.action_id = validate_action_id(action_id)\n        self.initial_value = initial_value\n        self.dispatch_action_config = dispatch_action_config\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder,\n            force_plaintext=True,\n            max_length=150,\n            allow_none=True,\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        url_input = self._attributes()\n        url_input[\"action_id\"] = self.action_id\n        if self.initial_value is not None:\n            url_input[\"initial_value\"] = self.initial_value\n        if self.dispatch_action_config:\n            url_input[\"dispatch_action_config\"] = self.dispatch_action_config._resolve()\n        if self.focus_on_load:\n            url_input[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            url_input[\"placeholder\"] = self.placeholder\n        return url_input\n</code></pre>"},{"location":"reference/elements/#elements.UserMultiSelectMenu","title":"UserMultiSelectMenu","text":"<p>This interactive UI element allows users to select multiple users visible     to the current user in the active workspace.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#users_multi_select.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_users</code> <code>Optional[List[str]]</code> <p>a list of string user IDs to be intially selected when the element is first rendered.</p> <code>None</code> <code>confirm</code> <code>ConfirmationDialogue</code> <p>a <code>ConfirmationDialogue</code> object that will be presented when the menu is used.</p> <code>None</code> <code>max_selected_items</code> <code>Optional[int]</code> <p>the highest number of items from the list that can be selected at one time.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the menu will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the menu when it's initially rendered.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class UserMultiSelectMenu(Element):\n    \"\"\"\n    This interactive UI element allows users to select multiple users visible\n        to the current user in the active workspace.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#users_multi_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_users: a list of string user IDs to be intially selected\n            when the element is first rendered.\n        confirm: a `ConfirmationDialogue` object that will be presented when\n            the menu is used.\n        max_selected_items: the highest number of items from the list that\n            can be selected at one time.\n        focus_on_load: whether or not the menu will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the menu when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_users: Optional[List[str]] = None,\n        confirm: ConfirmationDialogue = None,\n        max_selected_items: Optional[int] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.MULTI_SELECT_USERS)\n        self.action_id = validate_action_id(action_id)\n        self.initial_users = coerce_to_list(initial_users, str, allow_none=True)\n        self.confirm = confirm\n        self.max_selected_items = max_selected_items\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, force_plaintext=True, max_length=150, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        user_multi_select = self._attributes()\n        user_multi_select[\"action_id\"] = self.action_id\n        if self.initial_users:\n            user_multi_select[\"initial_users\"] = self.initial_users\n        if self.confirm:\n            user_multi_select[\"confirm\"] = self.confirm._resolve()\n        if self.max_selected_items:\n            user_multi_select[\"max_selected_items\"] = self.max_selected_items\n        if self.focus_on_load:\n            user_multi_select[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            user_multi_select[\"placeholder\"] = self.placeholder._resolve()\n        return user_multi_select\n</code></pre>"},{"location":"reference/elements/#elements.UserSelectMenu","title":"UserSelectMenu","text":"<p>A select menu interactive UI element, sourced automatically with Slack users from the     current workspace visible to the current user.</p> <p>See: https://api.slack.com/reference/block-kit/block-elements#users_select.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>an identifier so the source of the action can be known.</p> required <code>initial_user</code> <code>Optional[str]</code> <p>the single (string) user ID that will be initially selected when first presented to the user.</p> <code>None</code> <code>confirm</code> <code>Optional[ConfirmationDialogue]</code> <p>a <code>ConfirmationDialogue</code> object that will be presented when an option in the overflow menu is selected.</p> <code>None</code> <code>focus_on_load</code> <code>bool</code> <p>whether or not the input will be set to autofocus within the view object.</p> <code>False</code> <code>placeholder</code> <code>Optional[TextLike]</code> <p>a plain-text <code>Text</code> object (max 150 chars) that shows in the input when it's initially rendered.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the provided arguments fail validation.</p> Source code in <code>slackblocks/elements.py</code> <pre><code>class UserSelectMenu(Element):\n    \"\"\"\n    A select menu interactive UI element, sourced automatically with Slack users from the\n        current workspace visible to the current user.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#users_select&gt;.\n\n    Args:\n        action_id: an identifier so the source of the action can be known.\n        initial_user: the single (string) user ID that will be initially selected\n            when first presented to the user.\n        confirm: a `ConfirmationDialogue` object that will be presented when an\n            option in the overflow menu is selected.\n        focus_on_load: whether or not the input will be set to autofocus\n            within the view object.\n        placeholder: a plain-text `Text` object (max 150 chars) that shows\n            in the input when it's initially rendered.\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        action_id: str,\n        initial_user: Optional[str] = None,\n        confirm: Optional[ConfirmationDialogue] = None,\n        focus_on_load: bool = False,\n        placeholder: Optional[TextLike] = None,\n    ):\n        super().__init__(type_=ElementType.USERS_SELECT_MENU)\n        self.action_id = validate_action_id(action_id)\n        self.initial_user = initial_user\n        self.confirm = confirm\n        self.focus_on_load = focus_on_load\n        self.placeholder = Text.to_text(\n            placeholder, max_length=150, force_plaintext=True, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        user_select_menu = self._attributes()\n        user_select_menu[\"action_id\"] = self.action_id\n        if self.initial_user:\n            user_select_menu[\"initial_user\"] = self.initial_user\n        if self.confirm:\n            user_select_menu[\"confirm\"] = self.confirm._resolve()\n        if self.focus_on_load:\n            user_select_menu[\"focus_on_load\"] = self.focus_on_load\n        if self.placeholder:\n            user_select_menu[\"placeholder\"] = self.placeholder._resolve()\n        return user_select_menu\n</code></pre>"},{"location":"reference/elements/#elements.WorkflowButton","title":"WorkflowButton","text":"<pre><code>An interactive component that allows users to run a link trigger with\n    customizable inputs.\n\nSee: &lt;https://api.slack.com/reference/block-kit/block-elements#workflow_button&gt;.\n\nArgs:\n    text: the text content that will appear in the button.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         workflow: a <code>Workflow</code> object =======         workflow: a <code>Workflow</code> object</p> <p>Stashed changes             that contains details about the workflow that will run when the             button is clicked.         style: one of <code>Default</code>, <code>Primary</code>, or <code>Danger</code>, determines the             visual style of the button. Consider using the <code>ButtonStyle</code>             object for this.         accessibility_label: a string label for longer descriptive text about             a button element. Used by screen readers (max 75 chars).</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation.\n</code></pre> Source code in <code>slackblocks/elements.py</code> <pre><code>class WorkflowButton(Element):\n    \"\"\"\n    An interactive component that allows users to run a link trigger with\n        customizable inputs.\n\n    See: &lt;https://api.slack.com/reference/block-kit/block-elements#workflow_button&gt;.\n\n    Args:\n        text: the text content that will appear in the button.\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        workflow: a [`Workflow`](/slackblocks/latest/reference/objects/#objects.Workflow) object\n=======\n        workflow: a [`Workflow`](/slackblocks/reference/objects/#objects.Workflow) object\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            that contains details about the workflow that will run when the\n            button is clicked.\n        style: one of `Default`, `Primary`, or `Danger`, determines the\n            visual style of the button. Consider using the `ButtonStyle`\n            object for this.\n        accessibility_label: a string label for longer descriptive text about\n            a button element. Used by screen readers (max 75 chars).\n\n    Throws:\n        InvalidUsageError: if any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        text: TextLike,\n        workflow: Optional[Workflow] = None,\n        style: Optional[ButtonStyleLike] = ButtonStyle.DEFAULT,\n        accessibility_label: Optional[str] = None,\n    ):\n        super().__init__(type_=ElementType.WORKFLOW_BUTTON)\n        self.text = Text.to_text(text, force_plaintext=True, max_length=75)\n        self.workflow = workflow\n        self.style = ButtonStyle.to_button_style(style).value\n        self.accessibility_label = accessibility_label\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        workflow_button = self._attributes()\n        workflow_button[\"text\"] = self.text._resolve()\n        if self.workflow:\n            workflow_button[\"workflow\"] = self.workflow._resolve()\n        if self.style is not None:\n            workflow_button[\"style\"] = self.style\n        if self.accessibility_label:\n            workflow_button[\"accessibility_label\"] = self.accessibility_label\n        return workflow_button\n</code></pre>"},{"location":"reference/messages/","title":"Messages","text":"<p>Messages are the core unit of Slack messaging functionality. They can be built out using blocks, elements, objects, and rich text features.</p> <p>See: https://api.slack.com/messaging</p>"},{"location":"reference/messages/#messages.Message","title":"Message","text":"<pre><code>A Slack message object that can be converted to a JSON string for use with\nthe Slack message API.\n\nArgs:\n    channel: the Slack channel to send the message to, e.g. \"#general\".\n    text: markdown text to send in the message. If `blocks` are provided\n        then this is a fallback to display in notifications.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         blocks: a list of <code>Blocks</code> to form the contents             of the message instead of the contents of <code>text</code>.         attachments: a list of             <code>Attachments</code> =======         blocks: a list of <code>Blocks</code> to form the contents             of the message instead of the contents of <code>text</code>.         attachments: a list of             <code>Attachments</code></p> <p>Stashed changes             that form the secondary contents of the message (deprecated).         thread_ts: the timestamp ID of another unthreaded message that will             become the parent message of this message (now a reply in a thread).         mrkdwn: if <code>True</code> the contents of <code>text</code> will be rendered as markdown             rather than plain text.         unfurl_links: if <code>True</code>, links in the message will be automatically             unfurled.         unfurl_media: if <code>True</code>, media from links (e.g. images) will             automatically unfurl.     Throws:         InvalidUsageException: in the event that the items passed to <code>blocks</code> &lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream             are not valid <code>Blocks</code>. =======             are not valid <code>Blocks</code>. Stashed changes</p> Source code in <code>slackblocks/messages.py</code> <pre><code>class Message(BaseMessage):\n    \"\"\"\n    A Slack message object that can be converted to a JSON string for use with\n    the Slack message API.\n\n    Args:\n        channel: the Slack channel to send the message to, e.g. \"#general\".\n        text: markdown text to send in the message. If `blocks` are provided\n            then this is a fallback to display in notifications.\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n        blocks: a list of [`Blocks`](/slackblocks/latest/reference/blocks) to form the contents\n            of the message instead of the contents of `text`.\n        attachments: a list of\n            [`Attachments`](/slackblocks/latest/reference/attachments/#attachments.Attachment)\n=======\n        blocks: a list of [`Blocks`](/slackblocks/reference/blocks) to form the contents\n            of the message instead of the contents of `text`.\n        attachments: a list of\n            [`Attachments`](/slackblocks/reference/attachments/#attachments.Attachment)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            that form the secondary contents of the message (deprecated).\n        thread_ts: the timestamp ID of another unthreaded message that will\n            become the parent message of this message (now a reply in a thread).\n        mrkdwn: if `True` the contents of `text` will be rendered as markdown\n            rather than plain text.\n        unfurl_links: if `True`, links in the message will be automatically\n            unfurled.\n        unfurl_media: if `True`, media from links (e.g. images) will\n            automatically unfurl.\n    Throws:\n        InvalidUsageException: in the event that the items passed to `blocks`\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n            are not valid [`Blocks`](/slackblocks/latest/reference/blocks).\n=======\n            are not valid [`Blocks`](/slackblocks/reference/blocks).\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n    \"\"\"\n\n    def __init__(\n        self,\n        channel: str,\n        text: Optional[str] = \"\",\n        blocks: Optional[Union[List[Block], Block]] = None,\n        attachments: Optional[List[Attachment]] = None,\n        thread_ts: Optional[str] = None,\n        mrkdwn: bool = True,\n        unfurl_links: Optional[bool] = None,\n        unfurl_media: Optional[bool] = None,\n    ) -&gt; \"Message\":\n        super().__init__(channel, text, blocks, attachments, thread_ts, mrkdwn)\n        self.unfurl_links = unfurl_links\n        self.unfurl_media = unfurl_media\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        result = {**super()._resolve()}\n        if self.unfurl_links is not None:\n            result[\"unfurl_links\"] = self.unfurl_links\n        if self.unfurl_media is not None:\n            result[\"unfurl_media\"] = self.unfurl_media\n        return result\n</code></pre>"},{"location":"reference/messages/#messages.ResponseType","title":"ResponseType","text":"<p>Types of messages that can be sent via <code>WebhookMessage</code>.</p> Source code in <code>slackblocks/messages.py</code> <pre><code>class ResponseType(Enum):\n    \"\"\"\n    Types of messages that can be sent via `WebhookMessage`.\n    \"\"\"\n\n    EPHEMERAL = \"ephemeral\"\n    IN_CHANNEL = \"in_channel\"\n\n    @staticmethod\n    def get_value(value: Union[\"ResponseType\", str]) -&gt; str:\n        if isinstance(value, ResponseType):\n            return value.value\n        if value not in [response_type.value for response_type in ResponseType]:\n            raise InvalidUsageError(\n                \"ResponseType must be either `ephemeral` or `in_channel`\"\n            )\n        return value\n</code></pre>"},{"location":"reference/messages/#messages.WebhookMessage","title":"WebhookMessage","text":"<pre><code>Messages sent via the Slack `WebhookClient` takes different arguments than\n    those sent via the regular `WebClient`.\n\nSee: &lt;https://github.com/slackapi/python-slack-sdk/blob/7e71b73/slack_sdk/webhook/client.py#L28&gt;\n\nArgs:\n    text: markdown text to send in the message. If `blocks` are provided\n        then this is a fallback to display in notifications.\n    attachments: a list of\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream             <code>Attachments</code>             that form the secondary contents of the message (deprecated).         blocks: a list of <code>Blocks</code> to form the contents =======             <code>Attachments</code>             that form the secondary contents of the message (deprecated).         blocks: a list of <code>Blocks</code> to form the contents</p> <p>Stashed changes             of the message instead of the contents of <code>text</code>.         response_type: one of <code>ResponseType.EPHEMERAL</code> or <code>ResponseType.IN_CHANNEL</code>.             Ephemeral messages are shown only to the requesting user whereas             \"in-channel\" messages are shown to all channel participants.         replace_orginal: when <code>True</code>, the message triggering this response will be             replaced by this messaage. Mutually exclusive with <code>delete_original</code>.         delete_original: when <code>True</code>, the original message triggering this response             will be deleted, and any content of this message will be posted as a             new message. Mutually exclusive with <code>replace_orginal</code>.         unfurl_links: if <code>True</code>, links in the message will be automatically             unfurled.         unfurl_media: if <code>True</code>, media from links (e.g. images) will             automatically unfurl.         metadata: additional metadata to attach to the message.         headres: HTTP request headers to include with the message.</p> <pre><code>Throws:\n    InvalidUsageError: when any of the passed fields fail validation.\n</code></pre> Source code in <code>slackblocks/messages.py</code> <pre><code>class WebhookMessage:\n    \"\"\"\n    Messages sent via the Slack `WebhookClient` takes different arguments than\n        those sent via the regular `WebClient`.\n\n    See: &lt;https://github.com/slackapi/python-slack-sdk/blob/7e71b73/slack_sdk/webhook/client.py#L28&gt;\n\n    Args:\n        text: markdown text to send in the message. If `blocks` are provided\n            then this is a fallback to display in notifications.\n        attachments: a list of\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n            [`Attachments`](/slackblocks/latest/reference/attachments/#attachments.Attachment)\n            that form the secondary contents of the message (deprecated).\n        blocks: a list of [`Blocks`](/slackblocks/latest/reference/blocks) to form the contents\n=======\n            [`Attachments`](/slackblocks/reference/attachments/#attachments.Attachment)\n            that form the secondary contents of the message (deprecated).\n        blocks: a list of [`Blocks`](/slackblocks/reference/blocks) to form the contents\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n            of the message instead of the contents of `text`.\n        response_type: one of `ResponseType.EPHEMERAL` or `ResponseType.IN_CHANNEL`.\n            Ephemeral messages are shown only to the requesting user whereas\n            \"in-channel\" messages are shown to all channel participants.\n        replace_orginal: when `True`, the message triggering this response will be\n            replaced by this messaage. Mutually exclusive with `delete_original`.\n        delete_original: when `True`, the original message triggering this response\n            will be deleted, and any content of this message will be posted as a\n            new message. Mutually exclusive with `replace_orginal`.\n        unfurl_links: if `True`, links in the message will be automatically\n            unfurled.\n        unfurl_media: if `True`, media from links (e.g. images) will\n            automatically unfurl.\n        metadata: additional metadata to attach to the message.\n        headres: HTTP request headers to include with the message.\n\n    Throws:\n        InvalidUsageError: when any of the passed fields fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Optional[str] = None,\n        attachments: Optional[List[Attachment]] = None,\n        blocks: Optional[Union[List[Block], Block]] = None,\n        response_type: Union[ResponseType, str] = None,\n        replace_original: Optional[bool] = None,\n        delete_original: Optional[bool] = None,\n        unfurl_links: Optional[bool] = None,\n        unfurl_media: Optional[bool] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        headers: Optional[Dict[str, str]] = None,\n    ) -&gt; \"WebhookMessage\":\n        self.text = text\n        self.attachments = coerce_to_list(attachments, Attachment, allow_none=True)\n        self.blocks = coerce_to_list(blocks, Block, allow_none=True)\n        self.response_type = ResponseType.get_value(response_type)\n        self.replace_original = replace_original\n        self.delete_original = delete_original\n        self.unfurl_links = unfurl_links\n        self.unfurl_media = unfurl_media\n        self.metadata = metadata\n        self.headers = headers\n\n    def _resolve(self) -&gt; None:\n        webhook_message = {}\n        if self.text is not None:\n            webhook_message[\"text\"] = self.text\n        if self.attachments is not None:\n            webhook_message[\"attachments\"] = [\n                attachment._resolve() for attachment in self.attachments\n            ]\n        if self.blocks is not None:\n            webhook_message[\"blocks\"] = [block._resolve() for block in self.blocks]\n        if self.response_type is not None:\n            webhook_message[\"response_type\"] = self.response_type\n        if self.replace_original is not None:\n            webhook_message[\"replace_original\"] = self.replace_original\n        if self.delete_original is not None:\n            webhook_message[\"delete_original\"] = self.delete_original\n        if self.unfurl_links is not None:\n            webhook_message[\"unfurl_links\"] = self.unfurl_links\n        if self.unfurl_media is not None:\n            webhook_message[\"unfurl_media\"] = self.unfurl_media\n        if self.metadata is not None:\n            webhook_message[\"metadata\"] = self.metadata\n        if self.headers is not None:\n            webhook_message[\"headers\"] = self.headers\n        return webhook_message\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return self._resolve()\n\n    def json(self) -&gt; str:\n        return dumps(self._resolve(), indent=4)\n\n    def __repr__(self) -&gt; str:\n        return self.json()\n\n    def __getitem__(self, item):\n        return self._resolve()[item]\n\n    def keys(self) -&gt; Dict[str, Any]:\n        return self._resolve().keys()\n</code></pre>"},{"location":"reference/modals/","title":"Modals","text":"<p>Modals are pop-up windows, primarily used for collecting data from users.</p> <p>This module is kept only for backwards compatibility, modals have been largely subsumed as a subtype of view.</p> <p>See: https://api.slack.com/surfaces/modals</p> <p>options:     show_bases: false</p>"},{"location":"reference/modals/#modals.Modal","title":"Modal","text":"<p>             Bases: <code>ModalView</code></p> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream     Kept for backwards compatibility - see         <code>ModalView</code> =======     Kept for backwards compatibility - see <code>ModalView</code></p> <p>Stashed changes</p> Source code in <code>slackblocks/modals.py</code> <pre><code>class Modal(ModalView):\n    \"\"\"\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n    Kept for backwards compatibility - see\n        [`ModalView`](/slackblocks/latest/reference/views/#views.ModalView)\n=======\n    Kept for backwards compatibility - see [`ModalView`](/slackblocks/reference/views/#views.ModalView)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n    \"\"\"\n\n    def __repr__(self) -&gt; str:\n        return dumps(self._resolve(), indent=4)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return self._resolve()\n\n    def json(self) -&gt; str:\n        return dumps(self._resolve(), indent=4)\n</code></pre>"},{"location":"reference/objects/","title":"Objects","text":"<p>Composition objects are the lowest-level primitives used inside of Block objects.</p> <p>See: https://api.slack.com/reference/block-kit/composition-objects.</p>"},{"location":"reference/objects/#objects.Confirm","title":"Confirm","text":"<pre><code>Alias for `ConfirmationDialogue` to retain backwards compatibility.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream     See:         <code>ConfirmationDialogue</code>.  # noqa: E501 =======     See: <code>ConfirmationDialogue</code>.</p> <p>Stashed changes</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class Confirm(ConfirmationDialogue):\n    \"\"\"\n    Alias for `ConfirmationDialogue` to retain backwards compatibility.\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream\n    See:\n        [`ConfirmationDialogue`](/slackblocks/latest/reference/objects/#objects.ConfirmationDialogue).  # noqa: E501\n=======\n    See: [`ConfirmationDialogue`](/slackblocks/reference/objects/#objects.ConfirmationDialogue).\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(*args, **kwargs)\n</code></pre>"},{"location":"reference/objects/#objects.ConfirmationDialogue","title":"ConfirmationDialogue","text":"<p>An object that defines a dialog that provides a confirmation step to any interactive element. This dialog will ask the user to confirm their action by offering confirm and deny buttons.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>TextLike</code> <p>the text heading presented at the top of the dialogue box (max 100 chars).</p> required <code>text</code> <code>TextLike</code> <p>the text explaining the decision being made by the user through the dialogue box (max 300 chars).</p> required <code>confirm</code> <code>TextLike</code> <p>the text inside the confirmation button of the dialogue box (max 30 chars).</p> required <code>deny</code> <code>TextLike</code> <p>the text inside the deny button of the dialogue box (max 30 chars).</p> required Throws <p>InvalidUsageError: if any of the arguments fail to pass validation checks.</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class ConfirmationDialogue(CompositionObject):\n    \"\"\"\n    An object that defines a dialog that provides a confirmation step\n    to any interactive element. This dialog will ask the user to confirm\n    their action by offering confirm and deny buttons.\n\n    Args:\n        title: the text heading presented at the top of the dialogue box (max 100 chars).\n        text: the text explaining the decision being made by the user through\n            the dialogue box (max 300 chars).\n        confirm: the text inside the confirmation button of the dialogue box (max 30 chars).\n        deny: the text inside the deny button of the dialogue box (max 30 chars).\n\n    Throws:\n        InvalidUsageError: if any of the arguments fail to pass validation checks.\n    \"\"\"\n\n    def __init__(\n        self,\n        title: TextLike,\n        text: TextLike,\n        confirm: TextLike,\n        deny: TextLike,\n    ):\n        super().__init__(type_=CompositionObjectType.CONFIRM)\n        self.title = Text.to_text(title, max_length=100, force_plaintext=True)\n        self.text = Text.to_text(text, max_length=300)\n        self.confirm = Text.to_text(confirm, max_length=30, force_plaintext=True)\n        self.deny = Text.to_text(deny, max_length=30, force_plaintext=True)\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        return {\n            \"title\": self.title._resolve(),\n            \"text\": self.text._resolve(),\n            \"confirm\": self.confirm._resolve(),\n            \"deny\": self.deny._resolve(),\n        }\n</code></pre>"},{"location":"reference/objects/#objects.ConversationFilter","title":"ConversationFilter","text":"<p>Provides a way to filter the list of options in a conversations select menu or conversations multi-select menu.</p> <p>See: https://api.slack.com/reference/block-kit/composition-objects#filter_conversations.</p> <p>At least one of the available arguments must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Union[str, List[str]]]</code> <p>Which types of conversations to include in the list. One of more of <code>im</code>, <code>mpim</code>, <code>private</code>, <code>public</code>.</p> <code>None</code> <code>exclude_external_shared_channels</code> <code>Optional[bool]</code> <p>whether to remove shared public channels from the list. See https://api.slack.com/enterprise/shared-channels.</p> <code>None</code> <code>exclude_bot_users</code> <code>Optional[bool]</code> <p>whether to remove bot users from the list of conversations.</p> <code>None</code> Throws <p>InvalidUsageException: in the event that the user provides none of <code>include</code>,     <code>exclude_external_shared_channels</code>, or <code>exclude_bot_users</code> arguments.</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class ConversationFilter(CompositionObject):\n    \"\"\"\n    Provides a way to filter the list of options in a conversations select menu or\n    conversations multi-select menu.\n\n    See: &lt;https://api.slack.com/reference/block-kit/composition-objects#filter_conversations&gt;.\n\n    At least one of the available arguments _must_ be provided.\n\n    Args:\n        include: Which types of conversations to include in the list.\n            One of more of `im`, `mpim`, `private`, `public`.\n        exclude_external_shared_channels: whether to remove shared public channels\n            from the list. See &lt;https://api.slack.com/enterprise/shared-channels&gt;.\n        exclude_bot_users: whether to remove bot users from the list of conversations.\n\n    Throws:\n        InvalidUsageException: in the event that the user provides none of `include`,\n            `exclude_external_shared_channels`, or `exclude_bot_users` arguments.\n    \"\"\"\n\n    def __init__(\n        self,\n        include: Optional[Union[str, List[str]]] = None,\n        exclude_external_shared_channels: Optional[bool] = None,\n        exclude_bot_users: Optional[bool] = None,\n    ) -&gt; \"ConversationFilter\":\n        super().__init__(type_=CompositionObjectType.FILTER)\n        if not (\n            include\n            or exclude_external_shared_channels is not None\n            or exclude_bot_users is not None\n        ):\n            raise InvalidUsageError(\n                \"One of `include`, `exclude_external_shared_channels`, or \"\n                \"`exclude_bot_users` is required.\"\n            )\n        self.include = coerce_to_list(include, str, allow_none=True)\n        self.exclude_external_shared_channels = exclude_external_shared_channels\n        self.exclude_bot_users = exclude_bot_users\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        filter = {}  # Does not include type in JSON\n        if self.include:\n            filter[\"include\"] = self.include\n        if self.exclude_external_shared_channels is not None:\n            filter[\"exclude_external_shared_channels\"] = (\n                self.exclude_external_shared_channels\n            )\n        if self.exclude_bot_users is not None:\n            filter[\"exclude_bot_users\"] = self.exclude_bot_users\n        return filter\n</code></pre>"},{"location":"reference/objects/#objects.DispatchActionConfiguration","title":"DispatchActionConfiguration","text":"<p>Determines when a plain-text input element will return a <code>block_action</code>s interaction payload.</p> <p>Parameters:</p> Name Type Description Default <code>trigger_actions_on</code> <code>Union[str, List[str]]</code> <p>a list of strings representing interaction types that should return a <code>block_actions</code> payload. One or both of <code>on_enter_pressed</code>, <code>on_character_entered</code>.</p> <code>None</code> Throws <p>InvalidUsageError: if an invalid value is provided amongst the options for     <code>trigger_actions_on</code>.</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class DispatchActionConfiguration(CompositionObject):\n    \"\"\"\n    Determines when a plain-text input element will return a `block_action`s interaction payload.\n\n    Args:\n        trigger_actions_on: a list of strings representing interaction types that should return\n            a `block_actions` payload. One or both of `on_enter_pressed`, `on_character_entered`.\n\n    Throws:\n        InvalidUsageError: if an invalid value is provided amongst the options for\n            `trigger_actions_on`.\n    \"\"\"\n\n    def __init__(self, trigger_actions_on: Union[str, List[str]] = None):\n        self.trigger_actions_on = list(\n            set(coerce_to_list(trigger_actions_on, str, min_size=1, max_size=2))\n        )\n        for trigger in self.trigger_actions_on:\n            if trigger not in ALLOWABLE_TRIGGERS:\n                raise InvalidUsageError(\n                    f\"Trigger {trigger} not in allowable values ({ALLOWABLE_TRIGGERS})\"\n                )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        dispatch_action_config = {}  # Does not include type in JSON\n        dispatch_action_config[\"trigger_actions_on\"] = self.trigger_actions_on\n        return dispatch_action_config\n</code></pre>"},{"location":"reference/objects/#objects.InputParameter","title":"InputParameter","text":"<p>Contains information about an input parameter.</p> <p>See https://api.slack.com/automation/workflows#defining-input-parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the input parameter.</p> required <code>value</code> <code>str</code> <p>the value associated with the input parameter.</p> required Source code in <code>slackblocks/objects.py</code> <pre><code>class InputParameter(CompositionObject):\n    \"\"\"\n    Contains information about an input parameter.\n\n    See &lt;https://api.slack.com/automation/workflows#defining-input-parameters&gt;.\n\n    Args:\n        name: the name of the input parameter.\n        value: the value associated with the input parameter.\n    \"\"\"\n\n    def __init__(self, name: str, value: str):\n        super().__init__(type_=CompositionObjectType.INPUT_PARAMETER)\n        self.name = name\n        self.value = value\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        input_parameter = {}  # Does not include type in JSON\n        input_parameter[\"name\"] = self.name\n        input_parameter[\"value\"] = self.value\n        return input_parameter\n</code></pre>"},{"location":"reference/objects/#objects.Option","title":"Option","text":"<p>An object that represents a single selectable item in a select menu, multi-select menu, checkbox group, radio button group, or overflow menu.</p> <p>See https://api.slack.com/reference/block-kit/composition-objects#option.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>TextLike</code> <p>the text identifying the option (that the user will see).</p> required <code>value</code> <code>str</code> <p>the underlying value of that option (not seen by the user).</p> required <code>description</code> <code>Optional[TextLike]</code> <p>a more detailed explanation of what the option means (user-facing).</p> <code>None</code> <code>url</code> <code>Optional[str]</code> <p>a URL to load in the user's browser when the option is clicked. Only available in <code>OverflowMenus</code>.</p> <code>None</code> Throws <p>InvalidUsageError: when any of the provided arguments fail validation.</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class Option(CompositionObject):\n    \"\"\"\n    An object that represents a single selectable item in a select menu, multi-select\n    menu, checkbox group, radio button group, or overflow menu.\n\n    See &lt;https://api.slack.com/reference/block-kit/composition-objects#option&gt;.\n\n    Args:\n        text: the text identifying the option (that the user will see).\n        value: the underlying value of that option (not seen by the user).\n        description: a more detailed explanation of what the option means (user-facing).\n        url: a URL to load in the user's browser when the option is clicked.\n            Only available in `OverflowMenus`.\n\n    Throws:\n        InvalidUsageError: when any of the provided arguments fail validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        text: TextLike,\n        value: str,\n        description: Optional[TextLike] = None,\n        url: Optional[str] = None,\n    ) -&gt; \"Option\":\n        super().__init__(type_=CompositionObjectType.OPTION)\n        self.text = Text.to_text(text, max_length=75)\n        self.value = validate_string(value, field_name=\"value\", max_length=75)\n        self.description = Text.to_text(\n            description, max_length=75, force_plaintext=True, allow_none=True\n        )\n        if url and len(url) &gt; 3000:\n            raise InvalidUsageError(\"Option URLs must be less than 3000 characters\")\n        self.url = url\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        option = {}  # Does not include type in JSON\n        option[\"text\"] = self.text._resolve()\n        option[\"value\"] = self.value\n        if self.description is not None:\n            option[\"description\"] = self.description._resolve()\n        if self.url is not None:\n            option[\"url\"] = self.url\n        return option\n\n    def __eq__(self, other) -&gt; bool:\n        return (\n            self.type == other.type\n            and self.text == other.text\n            and self.value == other.value\n            and self.description == other.description\n            and self.url == other.url\n        )\n</code></pre>"},{"location":"reference/objects/#objects.OptionGroup","title":"OptionGroup","text":"<p>Provides a way to group options in a select menu or multi-select menu.</p> <p>See https://api.slack.com/reference/block-kit/composition-objects#option_group.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>TextLike</code> <p>a label shown above the group of options.</p> required <code>options</code> <code>List[Option]</code> <p>a list of <code>Option</code> objects that will form the contents of the group (max 100).</p> required Throws <p>InvalidUsageError: if no options are provided or the label is not valid.</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class OptionGroup(CompositionObject):\n    \"\"\"\n    Provides a way to group options in a select menu or multi-select menu.\n\n    See &lt;https://api.slack.com/reference/block-kit/composition-objects#option_group&gt;.\n\n    Args:\n        label: a label shown above the group of options.\n        options: a list of `Option` objects that will form the contents of the group (max 100).\n\n    Throws:\n        InvalidUsageError: if no options are provided or the label is not valid.\n    \"\"\"\n\n    def __init__(self, label: TextLike, options: List[Option]):\n        super().__init__(type_=CompositionObjectType.OPTION_GROUP)\n        self.label = Text.to_text(label, max_length=75, force_plaintext=True)\n        self.options = coerce_to_list(\n            options,\n            class_=Option,\n            min_size=1,\n            max_size=100,\n            allow_none=False,\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        option_group = {}  # Does not include type in JSON\n        option_group[\"label\"] = self.label._resolve()\n        option_group[\"options\"] = [option._resolve() for option in self.options]\n        return option_group\n</code></pre>"},{"location":"reference/objects/#objects.SlackFile","title":"SlackFile","text":"<p>Defines an object containing Slack file information to be used in an image     block or image element.</p> <p>This file must be an image and you must provide either the URL or ID (not both).</p> <p>See: https://api.slack.com/reference/block-kit/composition-objects#slack_file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>the URL can be the <code>url_private</code> or the <code>permalink</code> of the Slack file (only one of <code>url</code> or <code>id</code> can be provided).</p> required <code>id</code> <code>Optional[str]</code> <p>the Slack ID of the file (only one of <code>url</code> or <code>id</code> can be provided).</p> required Throws <p>InvalidUsageError: if both <code>url</code> and <code>id</code> are provided</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class SlackFile(CompositionObject):\n    \"\"\"\n    Defines an object containing Slack file information to be used in an image\n        block or image element.\n\n    This file must be an image and you must provide either the URL or ID (not both).\n\n    See: &lt;https://api.slack.com/reference/block-kit/composition-objects#slack_file&gt;.\n\n    Args:\n        url: the URL can be the `url_private` or the `permalink` of the Slack file\n            (only one of `url` or `id` can be provided).\n        id: the Slack ID of the file\n            (only one of `url` or `id` can be provided).\n\n    Throws:\n        InvalidUsageError: if both `url` and `id` are provided\n    \"\"\"\n\n    def __init__(\n        self,\n        url: Optional[str],\n        id: Optional[str],\n    ) -&gt; \"SlackFile\":\n        super().__init__(CompositionObjectType.SLACK_FILE)\n        if url and id:\n            raise InvalidUsageError(\"Cannot provide both `url` and `id`.\")\n        self.url = url\n        self.id = id\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        file = {}  # Does not include type in JSON\n        if self.url:\n            file[\"url\"] = self.url\n        if self.id:\n            file[\"id\"] = self.id\n        return file\n</code></pre>"},{"location":"reference/objects/#objects.Text","title":"Text","text":"<p>An object containing some text, formatted either as <code>plain_text</code> or using Slack's <code>mrkdwn</code>.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the text to be rendered in a message (max 3000 characters).</p> required <code>type_</code> <code>TextType</code> <p>either <code>TextType.MARKDOWN</code> or <code>TextType.PLAINTEXT</code>.</p> <code>MARKDOWN</code> <code>emoji</code> <code>bool</code> <p>only usable with <code>TextType.PLAINTEXT</code>, if True: emoji will be escaped into text format (e.g. <code>:smile:</code>).</p> <code>False</code> <code>verbatim</code> <code>bool</code> <p>only usable with <code>TextType.MARKDOWN</code>, if True: links, channel names, user names will not automatically be rendered as links.</p> <code>False</code> Throws <p>InvalidUsageException: if the provided <code>text</code> fails validation.</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class Text(CompositionObject):\n    \"\"\"\n    An object containing some text, formatted either as `plain_text` or using\n    Slack's `mrkdwn`.\n\n    Args:\n        text: the text to be rendered in a message (max 3000 characters).\n        type_: either `TextType.MARKDOWN` or `TextType.PLAINTEXT`.\n        emoji: only usable with `TextType.PLAINTEXT`, if True: emoji will be\n            escaped into text format (e.g. `:smile:`).\n        verbatim: only usable with `TextType.MARKDOWN`, if True: links, channel\n            names, user names will not automatically be rendered as links.\n\n    Throws:\n        InvalidUsageException: if the provided `text` fails validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        type_: TextType = TextType.MARKDOWN,\n        emoji: bool = False,\n        verbatim: bool = False,\n    ) -&gt; \"Text\":\n        super().__init__(type_=CompositionObjectType.TEXT)\n        self.text_type = type_\n        self.text = validate_string(\n            text, field_name=\"text\", min_length=1, max_length=3000\n        )\n        if self.text_type == TextType.MARKDOWN:\n            self.verbatim = verbatim\n            self.emoji = None\n        elif self.text_type == TextType.PLAINTEXT:\n            self.verbatim = None\n            self.emoji = emoji\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        text = self._attributes()\n        text[\"type\"] = self.text_type.value\n        text[\"text\"] = self.text\n        if self.text_type == TextType.MARKDOWN and self.verbatim:\n            text[\"verbatim\"] = self.verbatim\n        elif self.text_type == TextType.PLAINTEXT and self.emoji:\n            text[\"emoji\"] = self.emoji\n        return text\n\n    @staticmethod\n    def to_text(\n        text: Optional[Union[str, \"Text\"]],\n        force_plaintext: bool = False,\n        max_length: Optional[int] = None,\n        allow_none: bool = False,\n    ) -&gt; Optional[\"Text\"]:\n        \"\"\"\n        Coerces `str` or `Text` objects into `Text` objects.\n\n        Args:\n            text: the `str` or `Text` object to ensure is in `Text` format.\n            force_plaintext: if `True`, forces the `str` or `Text` object\n                into a `Text` object with the type `TextType.PLAINTEXT`.\n            max_length: `text` will be checked against this length in addition\n                to the standard `Text` limit of 3000 characters.\n            allow_none: whether to accept `None` as a valid value for `text`.\n        \"\"\"\n        original_type = text.text_type if isinstance(text, Text) else None\n        type_ = (\n            TextType.PLAINTEXT\n            if force_plaintext\n            else original_type or TextType.MARKDOWN\n        )\n        if text is None:\n            if allow_none:\n                return None\n            raise InvalidUsageError(\"This field cannot have the value None or ''\")\n        if text and max_length and len(text) &gt; max_length:\n            raise InvalidUsageError(\n                f\"`text` length ({len(text)}) exceeds `max_length` ({max_length})\"\n            )\n        if isinstance(text, str):\n            return Text(text=text, type_=type_)\n        if isinstance(text, Text):\n\n            return Text(\n                text=text.text, type_=type_, emoji=text.emoji, verbatim=text.verbatim\n            )\n        else:\n            raise InvalidUsageError(\n                f\"Can only coerce Text object from `str` or `Text`, not `{type(text)}`\"\n            )\n\n    def __str__(self) -&gt; str:\n        return dumps(self._resolve())\n\n    def __len__(self) -&gt; int:\n        return len(self.text)\n\n    def __eq__(self, other) -&gt; bool:\n        return (\n            self.text_type == other.text_type\n            and self.text == other.text\n            and self.emoji == other.emoji\n            and self.vertbatim == other.verbatim\n        )\n</code></pre>"},{"location":"reference/objects/#objects.Text.to_text","title":"to_text  <code>staticmethod</code>","text":"<pre><code>to_text(\n    text,\n    force_plaintext=False,\n    max_length=None,\n    allow_none=False,\n)\n</code></pre> <p>Coerces <code>str</code> or <code>Text</code> objects into <code>Text</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Optional[Union[str, Text]]</code> <p>the <code>str</code> or <code>Text</code> object to ensure is in <code>Text</code> format.</p> required <code>force_plaintext</code> <code>bool</code> <p>if <code>True</code>, forces the <code>str</code> or <code>Text</code> object into a <code>Text</code> object with the type <code>TextType.PLAINTEXT</code>.</p> <code>False</code> <code>max_length</code> <code>Optional[int]</code> <p><code>text</code> will be checked against this length in addition to the standard <code>Text</code> limit of 3000 characters.</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>whether to accept <code>None</code> as a valid value for <code>text</code>.</p> <code>False</code> Source code in <code>slackblocks/objects.py</code> <pre><code>@staticmethod\ndef to_text(\n    text: Optional[Union[str, \"Text\"]],\n    force_plaintext: bool = False,\n    max_length: Optional[int] = None,\n    allow_none: bool = False,\n) -&gt; Optional[\"Text\"]:\n    \"\"\"\n    Coerces `str` or `Text` objects into `Text` objects.\n\n    Args:\n        text: the `str` or `Text` object to ensure is in `Text` format.\n        force_plaintext: if `True`, forces the `str` or `Text` object\n            into a `Text` object with the type `TextType.PLAINTEXT`.\n        max_length: `text` will be checked against this length in addition\n            to the standard `Text` limit of 3000 characters.\n        allow_none: whether to accept `None` as a valid value for `text`.\n    \"\"\"\n    original_type = text.text_type if isinstance(text, Text) else None\n    type_ = (\n        TextType.PLAINTEXT\n        if force_plaintext\n        else original_type or TextType.MARKDOWN\n    )\n    if text is None:\n        if allow_none:\n            return None\n        raise InvalidUsageError(\"This field cannot have the value None or ''\")\n    if text and max_length and len(text) &gt; max_length:\n        raise InvalidUsageError(\n            f\"`text` length ({len(text)}) exceeds `max_length` ({max_length})\"\n        )\n    if isinstance(text, str):\n        return Text(text=text, type_=type_)\n    if isinstance(text, Text):\n\n        return Text(\n            text=text.text, type_=type_, emoji=text.emoji, verbatim=text.verbatim\n        )\n    else:\n        raise InvalidUsageError(\n            f\"Can only coerce Text object from `str` or `Text`, not `{type(text)}`\"\n        )\n</code></pre>"},{"location":"reference/objects/#objects.TextType","title":"TextType","text":"<p>Allowable types for Slack Text objects.</p> tradional markdown formatting, see <p>https://api.slack.com/reference/surfaces/formatting#basic-formatting</p> <p>PLAINTEXT: simple Unicode text with no formatting (e.g. bold) features.</p> <p>N.B: some usages of Text objects only allow the <code>PLAINTEXT</code> variety.</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class TextType(Enum):\n    \"\"\"\n    Allowable types for Slack Text objects.\n\n    MARKDOWN: tradional markdown formatting, see\n        &lt;https://api.slack.com/reference/surfaces/formatting#basic-formatting&gt;\n    PLAINTEXT: simple Unicode text with no formatting (e.g. bold) features.\n\n    N.B: some usages of Text objects only allow the `PLAINTEXT` variety.\n    \"\"\"\n\n    MARKDOWN = \"mrkdwn\"\n    PLAINTEXT = \"plain_text\"\n</code></pre>"},{"location":"reference/objects/#objects.Trigger","title":"Trigger","text":"<p>Contains information about a trigger.</p> <p>See: https://api.slack.com/automation/triggers.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>a link trigger URL, see https://api.slack.com/automation/triggers/link</p> required <code>customizable_input_parameters</code> <code>Optional[Union[InputParameter, List[InputParameter]]]</code> <p>a list of <code>InputParameter</code> objects which map to those parameters defined on the Workflow in which they are provided.</p> required Throws <p>InvalidUsageError: when any of the items in     <code>customizable_input_parameters</code> is not a valid <code>InputParameter</code>.</p> Source code in <code>slackblocks/objects.py</code> <pre><code>class Trigger(CompositionObject):\n    \"\"\"\n    Contains information about a trigger.\n\n    See: &lt;https://api.slack.com/automation/triggers&gt;.\n\n    Args:\n        url: a link trigger URL, see\n            &lt;https://api.slack.com/automation/triggers/link&gt;\n        customizable_input_parameters: a list of `InputParameter` objects\n            which map to those parameters defined on the Workflow in\n            which they are provided.\n\n    Throws:\n        InvalidUsageError: when any of the items in\n            `customizable_input_parameters` is not a valid `InputParameter`.\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        customizable_input_parameters: Optional[\n            Union[InputParameter, List[InputParameter]]\n        ],\n    ) -&gt; \"Trigger\":\n        super().__init__(type_=CompositionObjectType.TRIGGER)\n        self.url = url\n        self.customizable_input_parameters = coerce_to_list(\n            customizable_input_parameters, InputParameter, allow_none=True\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        trigger = {}  # Does not include type in JSON\n        trigger[\"url\"] = self.url\n        if self.customizable_input_parameters:\n            trigger[\"customizable_input_parameters\"] = [\n                parameter._resolve() for parameter in self.customizable_input_parameters\n            ]\n        return trigger\n</code></pre>"},{"location":"reference/objects/#objects.Workflow","title":"Workflow","text":"<p>Contains information about a workflow.</p> <p>See https://api.slack.com/automation/workflows.</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>Trigger</code> <p>a <code>Trigger</code> object that will initiate the workflow.</p> required Source code in <code>slackblocks/objects.py</code> <pre><code>class Workflow(CompositionObject):\n    \"\"\"\n    Contains information about a workflow.\n\n    See &lt;https://api.slack.com/automation/workflows&gt;.\n\n    Args:\n        trigger: a `Trigger` object that will initiate the workflow.\n    \"\"\"\n\n    def __init__(self, trigger: Trigger) -&gt; \"Workflow\":\n        super().__init__(type_=CompositionObjectType.WORKFLOW)\n        self.trigger = trigger\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        workflow = {}  # Does not include type in JSON\n        workflow[\"trigger\"] = self.trigger._resolve()\n        return workflow\n</code></pre>"},{"location":"reference/rich_text/","title":"Rich Text","text":"<p>Rich Text elements can be used to enhance text-based messages with code, list, quotations and formatted text (including options not available in traditional markdown like strikethrough).</p> <p>These formatting elements can only be used within a <code>RichTextBlock</code>.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#rich_text.</p>"},{"location":"reference/rich_text/#rich-text-elements-primitives","title":"Rich Text Elements (Primitives)","text":"<p>Rich text elements are the primitive elements used to populate the rich     text object \"containers\", which are then fed into the     <code>RichTextBlock</code>.</p>"},{"location":"reference/rich_text/#rich_text.elements.RichText","title":"RichText","text":"<p>The core unit of the rich text API. Allows for the formatting of text     with visual styles like bolding, italics and strikethroughs.     Combined with higher-level containers like <code>RichTextSection</code>,     <code>RichText</code> can be used to create complicated and deeply nested     rich text within Slack messages.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the text content to render.</p> required <code>bold</code> <code>Optional[bool]</code> <p>whether to render the given text in bold font.</p> <code>None</code> <code>italic</code> <code>Optional[bool]</code> <p>whether to render the given text in italics.</p> <code>None</code> <code>strike</code> <code>Optional[bool]</code> <p>whether to render the given text with a \"strikethrough\".</p> <code>None</code> <code>code</code> <code>Optional[bool]</code> <p>whether to render the given text as an inline code snippet (monospaced).</p> <code>None</code> Source code in <code>slackblocks/rich_text/elements.py</code> <pre><code>class RichText(RichTextElement):\n    \"\"\"\n    The core unit of the rich text API. Allows for the formatting of text\n        with visual styles like bolding, italics and strikethroughs.\n        Combined with higher-level containers like `RichTextSection`,\n        `RichText` can be used to create complicated and deeply nested\n        rich text within Slack messages.\n\n    Args:\n        text: the text content to render.\n        bold: whether to render the given text in bold font.\n        italic: whether to render the given text in italics.\n        strike: whether to render the given text with a \"strikethrough\".\n        code: whether to render the given text as an inline code snippet\n            (monospaced).\n    \"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        bold: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        code: Optional[bool] = None,\n    ) -&gt; None:\n        super().__init__(type_=RichTextElementType.TEXT)\n        self.text = text\n        self.bold = bold\n        self.italic = italic\n        self.strike = strike\n        self.code = code\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        rich_text = super()._resolve()\n        rich_text[\"text\"] = self.text\n        style = {}\n        if self.bold is not None:\n            style[\"bold\"] = self.bold\n        if self.italic is not None:\n            style[\"italic\"] = self.italic\n        if self.strike is not None:\n            style[\"strike\"] = self.strike\n        if self.code is not None:\n            style[\"code\"] = self.code\n        if style:\n            rich_text[\"style\"] = style\n        return rich_text\n</code></pre>"},{"location":"reference/rich_text/#rich_text.elements.RichTextChannel","title":"RichTextChannel","text":"<p>Rich text rendering of a Slack channel (e.g. #general).</p> <p>See: https://api.slack.com/reference/block-kit/blocks#channel-element-type</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>str</code> <p>the ID of the channel to render. You can get this from the channel settings or the URL (if using Slack in the browser).</p> required <code>bold</code> <code>Optional[bool]</code> <p>whether to render the given channel in bold font.</p> <code>None</code> <code>italic</code> <code>Optional[bool]</code> <p>whether to render the given channel in italics.</p> <code>None</code> <code>strike</code> <code>Optional[bool]</code> <p>whether to render the given channel with a \"strikethrough\".</p> <code>None</code> <code>highlight</code> <code>Optional[bool]</code> <p>whether to give the channel a distinct highlight when rendered.</p> <code>None</code> <code>client_highlight</code> <code>Optional[bool]</code> <p>???</p> <code>None</code> <code>unlink</code> <code>Optional[bool]</code> <p>whether to remove the link to the channel from the channel when rendered.</p> <code>None</code> Source code in <code>slackblocks/rich_text/elements.py</code> <pre><code>class RichTextChannel(RichTextElement):\n    \"\"\"\n    Rich text rendering of a Slack channel (e.g. #general).\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#channel-element-type&gt;\n\n    Args:\n        channel_id: the ID of the channel to render. You can get this from\n            the channel settings or the URL (if using Slack in the browser).\n        bold: whether to render the given channel in bold font.\n        italic: whether to render the given channel in italics.\n        strike: whether to render the given channel with a \"strikethrough\".\n        highlight: whether to give the channel a distinct highlight when rendered.\n        client_highlight: ???\n        unlink: whether to remove the link to the channel from the channel when\n            rendered.\n    \"\"\"\n\n    def __init__(\n        self,\n        channel_id: str,\n        bold: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        client_highlight: Optional[bool] = None,\n        unlink: Optional[bool] = None,\n    ) -&gt; None:\n        super().__init__(RichTextElementType.CHANNEL)\n        self.channel_id = channel_id\n        self.bold = bold\n        self.italic = italic\n        self.strike = strike\n        self.highlight = highlight\n        self.client_highlight = client_highlight\n        self.unlink = unlink\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        channel = super()._resolve()\n        channel[\"channel_id\"] = self.channel_id\n        style = {}\n        if self.bold is not None:\n            style[\"bold\"] = self.bold\n        if self.italic is not None:\n            style[\"italic\"] = self.italic\n        if self.strike is not None:\n            style[\"strike\"] = self.strike\n        if self.highlight is not None:\n            style[\"highlight\"] = self.highlight\n        if self.client_highlight is not None:\n            style[\"client_highlight\"] = self.client_highlight\n        if self.unlink is not None:\n            style[\"unlink\"] = self.unlink\n        if style:\n            channel[\"style\"] = style\n        return channel\n</code></pre>"},{"location":"reference/rich_text/#rich_text.elements.RichTextEmoji","title":"RichTextEmoji","text":"<p>A rich text element for displaying an emoji.</p> <p>The emoji can either be one built in to Slack or a custom workspace emoji.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#emoji-element-type</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the unique name of the emoji to represent e.g. \"wave\".</p> required Throws <p>InvalidUsageError: if the emoji <code>name</code> provided is empty.</p> Source code in <code>slackblocks/rich_text/elements.py</code> <pre><code>class RichTextEmoji(RichTextElement):\n    \"\"\"\n    A rich text element for displaying an emoji.\n\n    The emoji can either be one built in to Slack or a custom workspace emoji.\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#emoji-element-type&gt;\n\n    Args:\n        name: the unique name of the emoji to represent e.g. \"wave\".\n\n    Throws:\n        InvalidUsageError: if the emoji `name` provided is empty.\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        super().__init__(RichTextElementType.EMOJI)\n        self.name = validate_string(name, field_name=\"name\", min_length=1)\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        emoji = super()._resolve()\n        emoji[\"name\"] = self.name\n        return emoji\n</code></pre>"},{"location":"reference/rich_text/#rich_text.elements.RichTextLink","title":"RichTextLink","text":"<p>A rich text primitive to display links in text.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#link-element-type</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the url which the link will point to.</p> required <code>text</code> <code>Optional[str]</code> <p>the text to render with the link. If not provided, the raw URL will be used.</p> <code>None</code> <code>unsafe</code> <code>Optional[bool]</code> <p>whether the link is \"safe\".</p> <code>None</code> <code>bold</code> <code>Optional[bool]</code> <p>whether to render the given text in bold font.</p> <code>None</code> <code>italic</code> <code>Optional[bool]</code> <p>whether to render the given text in italics.</p> <code>None</code> <code>strike</code> <code>Optional[bool]</code> <p>whether to render the given text with a \"strikethrough\".</p> <code>None</code> <code>code</code> <code>Optional[bool]</code> <p>whether to render the given text as an inline code snippet (monospaced).</p> <code>None</code> Source code in <code>slackblocks/rich_text/elements.py</code> <pre><code>class RichTextLink(RichTextElement):\n    \"\"\"\n    A rich text primitive to display links in text.\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#link-element-type&gt;\n\n    Args:\n        url: the url which the link will point to.\n        text: the text to render with the link. If not provided, the raw URL\n            will be used.\n        unsafe: whether the link is \"safe\".\n        bold: whether to render the given text in bold font.\n        italic: whether to render the given text in italics.\n        strike: whether to render the given text with a \"strikethrough\".\n        code: whether to render the given text as an inline code snippet\n            (monospaced).\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        text: Optional[str] = None,\n        unsafe: Optional[bool] = None,\n        bold: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        code: Optional[bool] = None,\n    ) -&gt; None:\n        super().__init__(type_=RichTextElementType.LINK)\n        self.url = url\n        self.text = text\n        self.unsafe = unsafe\n        self.bold = bold\n        self.italic = italic\n        self.strike = strike\n        self.code = code\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        link = super()._resolve()\n        link[\"url\"] = self.url\n        if self.text is not None:\n            link[\"text\"] = self.text\n        if self.unsafe is not None:\n            link[\"unsafe\"] = self.unsafe\n        style = {}\n        if self.bold is not None:\n            style[\"bold\"] = self.bold\n        if self.italic is not None:\n            style[\"italic\"] = self.italic\n        if self.strike is not None:\n            style[\"strike\"] = self.strike\n        if self.code is not None:\n            style[\"code\"] = self.code\n        if style:\n            link[\"style\"] = style\n        return link\n</code></pre>"},{"location":"reference/rich_text/#rich_text.elements.RichTextUser","title":"RichTextUser","text":"<p>Rich text element for representing users in     <code>RichTextBlocks</code>.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#user-element-type.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>the Slack ID of the user in question, you can get these from users' profiles or Slack client requests.</p> required <code>bold</code> <code>Optional[bool]</code> <p>whether to render the given user in bold font.</p> <code>None</code> <code>italic</code> <code>Optional[bool]</code> <p>whether to render the given user in italics.</p> <code>None</code> <code>strike</code> <code>Optional[bool]</code> <p>whether to render the given user with a \"strikethrough\".</p> <code>None</code> <code>highlight</code> <code>Optional[bool]</code> <p>whether to give the user a distinct highlight when rendered.</p> <code>None</code> <code>client_highlight</code> <code>Optional[bool]</code> <p>???</p> <code>None</code> <code>unlink</code> <code>Optional[bool]</code> <p>whether to remove the link to the user from the channel when rendered.</p> <code>None</code> Source code in <code>slackblocks/rich_text/elements.py</code> <pre><code>class RichTextUser(RichTextElement):\n    \"\"\"\n    Rich text element for representing users in\n        [`RichTextBlocks`](/slackblocks/latest/reference/blocks/#blocks.RichTextBlock).\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#user-element-type&gt;.\n\n    Args:\n        user_id: the Slack ID of the user in question, you can get these\n            from users' profiles or Slack client requests.\n        bold: whether to render the given user in bold font.\n        italic: whether to render the given user in italics.\n        strike: whether to render the given user with a \"strikethrough\".\n        highlight: whether to give the user a distinct highlight when rendered.\n        client_highlight: ???\n        unlink: whether to remove the link to the user from the channel when\n            rendered.\n    \"\"\"\n\n    def __init__(\n        self,\n        user_id: str,\n        bold: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        client_highlight: Optional[bool] = None,\n        unlink: Optional[bool] = None,\n    ) -&gt; None:\n        super().__init__(RichTextElementType.USER)\n        self.user_id = user_id\n        self.bold = bold\n        self.italic = italic\n        self.strike = strike\n        self.highlight = highlight\n        self.client_highlight = client_highlight\n        self.unlink = unlink\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        user = super()._resolve()\n        user[\"user_id\"] = self.user_id\n        style = {}\n        if self.bold is not None:\n            style[\"bold\"] = self.bold\n        if self.italic is not None:\n            style[\"italic\"] = self.italic\n        if self.strike is not None:\n            style[\"strike\"] = self.strike\n        if self.highlight is not None:\n            style[\"highlight\"] = self.highlight\n        if self.client_highlight is not None:\n            style[\"client_highlight\"] = self.client_highlight\n        if self.unlink is not None:\n            style[\"unlink\"] = self.unlink\n        if style:\n            user[\"style\"] = style\n        return user\n</code></pre>"},{"location":"reference/rich_text/#rich_text.elements.RichTextUserGroup","title":"RichTextUserGroup","text":"<p>Rich text element for representing groups of users in     <code>RichTextBlocks</code>`.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#user-element-type.</p> <p>Parameters:</p> Name Type Description Default <code>user_group_id</code> <code>str</code> <p>the Slack ID of the user group being represented.</p> required <code>bold</code> <code>Optional[bool]</code> <p>whether to render the given user in bold font.</p> <code>None</code> <code>italic</code> <code>Optional[bool]</code> <p>whether to render the given user in italics.</p> <code>None</code> <code>strike</code> <code>Optional[bool]</code> <p>whether to render the given user with a \"strikethrough\".</p> <code>None</code> <code>highlight</code> <code>Optional[bool]</code> <p>whether to give the user a distinct highlight when rendered.</p> <code>None</code> <code>client_highlight</code> <code>Optional[bool]</code> <p>???</p> <code>None</code> <code>unlink</code> <code>Optional[bool]</code> <p>whether to remove the link to the user from the channel when rendered.</p> <code>None</code> Source code in <code>slackblocks/rich_text/elements.py</code> <pre><code>class RichTextUserGroup(RichTextElement):\n    \"\"\"\n    Rich text element for representing groups of users in\n        [`RichTextBlocks`](/slackblocks/latest/reference/blocks/#blocks.RichTextBlock)`.\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#user-element-type&gt;.\n\n    Args:\n        user_group_id: the Slack ID of the user group being represented.\n        bold: whether to render the given user in bold font.\n        italic: whether to render the given user in italics.\n        strike: whether to render the given user with a \"strikethrough\".\n        highlight: whether to give the user a distinct highlight when rendered.\n        client_highlight: ???\n        unlink: whether to remove the link to the user from the channel when\n            rendered.\n    \"\"\"\n\n    def __init__(\n        self,\n        user_group_id: str,\n        bold: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        client_highlight: Optional[bool] = None,\n        unlink: Optional[bool] = None,\n    ) -&gt; None:\n        super().__init__(RichTextElementType.USER_GROUP)\n        self.user_group_id = user_group_id\n        self.bold = bold\n        self.italic = italic\n        self.strike = strike\n        self.highlight = highlight\n        self.client_highlight = client_highlight\n        self.unlink = unlink\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        user_group = super()._resolve()\n        user_group[\"user_group_id\"] = self.user_group_id\n        style = {}\n        if self.bold is not None:\n            style[\"bold\"] = self.bold\n        if self.italic is not None:\n            style[\"italic\"] = self.italic\n        if self.strike is not None:\n            style[\"strike\"] = self.strike\n        if self.highlight is not None:\n            style[\"highlight\"] = self.highlight\n        if self.client_highlight is not None:\n            style[\"client_highlight\"] = self.client_highlight\n        if self.unlink is not None:\n            style[\"unlink\"] = self.unlink\n        if style:\n            user_group[\"style\"] = style\n        return user_group\n</code></pre>"},{"location":"reference/rich_text/#rich-text-objects-containers","title":"Rich Text Objects (Containers)","text":"<p>Rich text objects are containers for rich text elements.</p> <p>These obejects form the contents of the     <code>RichTextBlock</code>.</p>"},{"location":"reference/rich_text/#rich_text.objects.ListType","title":"ListType","text":"<p>An <code>Enum</code> that lists the available types of rich text lists.</p> <ul> <li><code>ListType.BULLET</code>: an unorderd (bulleted) list.</li> <li><code>ListType.ORDERED</code>: an ordered (numbered) list.</li> </ul> Source code in <code>slackblocks/rich_text/objects.py</code> <pre><code>class ListType(Enum):\n    \"\"\"\n    An `Enum` that lists the available types of rich text lists.\n\n    - `ListType.BULLET`: an unorderd (bulleted) list.\n    - `ListType.ORDERED`: an ordered (numbered) list.\n    \"\"\"\n\n    BULLET = \"bullet\"\n    ORDERED = \"ordered\"\n\n    def all() -&gt; List[str]:\n        return [list_type.value for list_type in ListType]\n</code></pre>"},{"location":"reference/rich_text/#rich_text.objects.RichTextCodeBlock","title":"RichTextCodeBlock","text":"<p>A rich text element for representing blocks of code in     <code>RichTextBlocks</code>.</p> <p>This is roughly equivalent to the triple-backtick ```<code>code</code>``` syntax in markdown.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#rich_text_preformatted.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Union[RichTextElement, List[RichTextElement]]</code> <p>one or more rich text primitive objexts (e.g. <code>RichText</code>).</p> required <code>border</code> <code>Optional[int]</code> <p>the thickness (in pixels) of the border around the code block.</p> <code>None</code> Throws <p>InvalidUsageError: if any of the items in <code>elements</code> aren't valid rich     text elements.</p> Source code in <code>slackblocks/rich_text/objects.py</code> <pre><code>class RichTextCodeBlock(RichTextObject):\n    \"\"\"\n    A rich text element for representing blocks of code in\n        [`RichTextBlocks`](reference/blocks/#blocks.RichTextBlock).\n\n    This is roughly equivalent to the triple-backtick \\`\\`\\``code`\\`\\`\\` syntax in markdown.\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#rich_text_preformatted&gt;.\n\n    Args:\n        elements: one or more rich text primitive objexts\n            (e.g. [`RichText`](/slackblocks/latest/reference/rich_text/#rich_text.RichText)).\n        border: the thickness (in pixels) of the border around the code block.\n\n    Throws:\n        InvalidUsageError: if any of the items in `elements` aren't valid rich\n            text elements.\n    \"\"\"\n\n    def __init__(\n        self,\n        elements: Union[RichTextElement, List[RichTextElement]],\n        border: Optional[int] = None,\n    ) -&gt; None:\n        super().__init__(type_=RichTextObjectType.PREFORMATTED)\n        self.elements = coerce_to_list(\n            elements,\n            (\n                RichText,\n                RichTextChannel,\n                RichTextEmoji,\n                RichTextLink,\n                RichTextUser,\n                RichTextUserGroup,\n            ),\n        )\n        self.border = border\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        preformatted = super()._resolve()\n        preformatted[\"elements\"] = [element._resolve() for element in self.elements]\n        if self.border is not None:\n            preformatted[\"border\"] = self.border\n        return preformatted\n</code></pre>"},{"location":"reference/rich_text/#rich_text.objects.RichTextList","title":"RichTextList","text":"<p>Renders to a HTML list containing rich text elements.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#rich_text_list.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>Union[str, ListType]</code> <p>one of <code>ListType.BULLET</code> or <code>ListType.ORDERED</code>.</p> required <code>elements</code> <code>Union[RichTextSection, List[RichTextSection]]</code> <p>a list of (possibly nested) <code>RichTextSection</code> elements. Each object in this list will be rendered as a list item.</p> required <code>indent</code> <code>Optional[int]</code> <p>indent (in pixels) of each list item.</p> <code>None</code> <code>offset</code> <code>Optional[int]</code> <p>offset (in pixels) of each list item.</p> <code>0</code> <code>border</code> <code>Optional[int]</code> <p>thickness (in pixels) of the (optional) border around the list.</p> <code>0</code> Throws <p>InvalidUsageError: if style is not a valid <code>ListType</code> or any of the     items in <code>elements</code> isn't a valid <code>RichTextSection</code>.</p> Source code in <code>slackblocks/rich_text/objects.py</code> <pre><code>class RichTextList(RichTextObject):\n    \"\"\"\n    Renders to a HTML list containing rich text elements.\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#rich_text_list&gt;.\n\n    Args:\n        style: one of `ListType.BULLET` or `ListType.ORDERED`.\n        elements: a list of (possibly nested) `RichTextSection` elements.\n            Each object in this list will be rendered as a list item.\n        indent: indent (in pixels) of each list item.\n        offset: offset (in pixels) of each list item.\n        border: thickness (in pixels) of the (optional) border around the list.\n\n    Throws:\n        InvalidUsageError: if style is not a valid `ListType` or any of the\n            items in `elements` isn't a valid `RichTextSection`.\n    \"\"\"\n\n    def __init__(\n        self,\n        style: Union[str, ListType],\n        elements: Union[RichTextSection, List[RichTextSection]],\n        indent: Optional[int] = None,\n        offset: Optional[int] = 0,\n        border: Optional[int] = 0,\n    ) -&gt; None:\n        super().__init__(type_=RichTextObjectType.LIST)\n        if isinstance(style, str):\n            if style in ListType.all():\n                self.style = style\n            else:\n                raise InvalidUsageError(f\"`style` must be one of [{ListType.all()}]\")\n        elif isinstance(style, ListType):\n            self.style = style.value\n        self.elements = coerce_to_list(elements, RichTextSection, min_size=1)\n        self.indent = validate_int(indent, allow_none=True)\n        self.offset = validate_int(offset, allow_none=True)\n        self.border = validate_int(border, allow_none=True)\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        rich_text_list = super()._resolve()\n        rich_text_list[\"elements\"] = [element._resolve() for element in self.elements]\n        rich_text_list[\"style\"] = self.style\n        if self.indent is not None:\n            rich_text_list[\"indent\"] = self.indent\n        if self.offset is not None:\n            rich_text_list[\"offset\"] = self.offset\n        if self.border is not None:\n            rich_text_list[\"border\"] = self.border\n        return rich_text_list\n</code></pre>"},{"location":"reference/rich_text/#rich_text.objects.RichTextQuote","title":"RichTextQuote","text":"<p>A rich text object for representing a block quote.</p> <p>Block quotes are presented with a vertical bar to the left hand side of     the text.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#rich_text_quote</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Union[RichTextElement, List[RichTextElement]]</code> <p>one or more rich text primitive objexts (e.g. <code>RichText</code>).</p> required <code>border</code> <code>Optional[int]</code> <p>the thickness (in pixels) of the border around the code block.</p> <code>None</code> Source code in <code>slackblocks/rich_text/objects.py</code> <pre><code>class RichTextQuote(RichTextObject):\n    \"\"\"\n    A rich text object for representing a block quote.\n\n    Block quotes are presented with a vertical bar to the left hand side of\n        the text.\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#rich_text_quote&gt;\n\n    Args:\n        elements: one or more rich text primitive objexts\n            (e.g. [`RichText`](/slackblocks/latest/reference/rich_text/#rich_text.RichText)).\n        border: the thickness (in pixels) of the border around the code block.\n    \"\"\"\n\n    def __init__(\n        self,\n        elements: Union[RichTextElement, List[RichTextElement]],\n        border: Optional[int] = None,\n    ) -&gt; None:\n        super().__init__(RichTextObjectType.QUOTE)\n        self.elements = coerce_to_list(\n            elements,\n            (\n                RichText,\n                RichTextChannel,\n                RichTextEmoji,\n                RichTextLink,\n                RichTextUser,\n                RichTextUserGroup,\n            ),\n        )\n        self.border = border\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        quote = super()._resolve()\n        quote[\"elements\"] = [element._resolve() for element in self.elements]\n        if self.border is not None:\n            quote[\"border\"] = self.border\n        return quote\n</code></pre>"},{"location":"reference/rich_text/#rich_text.objects.RichTextSection","title":"RichTextSection","text":"<p>The most basic rich text container object, which takes rich text elements     and renders them when <code>RichTextSection</code> is passed to a     <code>RichTextBlock</code>.</p> <p>See: https://api.slack.com/reference/block-kit/blocks#rich_text_section.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Union[RichTextElement, List[RichTextElement]]</code> <p>one or more rich text elements that will form the content of the section. e.g. <code>RichText</code>, <code>RichTextLink</code>.</p> required Throws <p>InvalidUsageError: if any of the items passed to <code>elements</code> isn't a valid     <code>RichTextObject</code>.</p> Source code in <code>slackblocks/rich_text/objects.py</code> <pre><code>class RichTextSection(RichTextObject):\n    \"\"\"\n    The most basic rich text container object, which takes rich text elements\n        and renders them when `RichTextSection` is passed to a\n        [`RichTextBlock`](/slackblocks/latest/reference/blocks/#blocks.RichTextBlock).\n\n    See: &lt;https://api.slack.com/reference/block-kit/blocks#rich_text_section&gt;.\n\n    Args:\n        elements: one or more rich text elements that will form the content of the section.\n            e.g. `RichText`, `RichTextLink`.\n\n    Throws:\n        InvalidUsageError: if any of the items passed to `elements` isn't a valid\n            `RichTextObject`.\n    \"\"\"\n\n    def __init__(self, elements: Union[RichTextElement, List[RichTextElement]]) -&gt; None:\n        super().__init__(type_=RichTextObjectType.SECTION)\n        self.elements = coerce_to_list(\n            elements,\n            class_=(\n                RichTextChannel,\n                RichTextEmoji,\n                RichTextLink,\n                RichText,\n                RichTextUser,\n                RichTextUserGroup,\n            ),\n            min_size=1,\n        )\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        section = super()._resolve()\n        section[\"elements\"] = [element._resolve() for element in self.elements]\n        return section\n</code></pre>"},{"location":"reference/utils/","title":"Utilities","text":"<p>This module collects various utility functions used for validating the input to <code>Messages</code>, <code>Blocks</code>, <code>Elements</code> and <code>Objects</code>.</p>"},{"location":"reference/utils/#utils.coerce_to_list","title":"coerce_to_list","text":"<pre><code>coerce_to_list(\n    object_or_objects,\n    class_,\n    allow_none=False,\n    min_size=None,\n    max_size=None,\n)\n</code></pre> <p>Takes and object or list of objects and validates its contents, ensuring that the resulting object is a list.</p> <p>Parameters:</p> Name Type Description Default <code>object_or_objects</code> <code>Union[T, List[T]]</code> <p>the Python object or objects to validate and convert to a list.</p> required <code>class_</code> <code>Union[Any, List[Any]]</code> <p>the Python type (or class) of objects expected in the list.</p> required <code>allow_none</code> <code>bool</code> <p>whether or not None is a valid input (and thus output) option.</p> <code>False</code> <code>min_size</code> <code>Optional[int]</code> <p>if provided, the length of <code>object_or_objects</code> cannot be smaller than this.</p> <code>None</code> <code>max_size</code> <code>Optional[int]</code> <p>if provided, the length of <code>object_or_objects</code> cannot be larger than this.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[T]</code> <p><code>object_or_objects</code> if it was a valid list, <code>[object_or_objects]</code> if it was a valid object, or <code>None</code> if provided and allowed.</p> Throws <p>InvalidUsageError: if any of the validation checks fail.</p> Source code in <code>slackblocks/utils.py</code> <pre><code>def coerce_to_list(\n    object_or_objects: Union[T, List[T]],\n    class_: Union[Any, List[Any]],\n    allow_none: bool = False,\n    min_size: Optional[int] = None,\n    max_size: Optional[int] = None,\n) -&gt; List[T]:\n    \"\"\"\n    Takes and object or list of objects and validates its contents, ensuring that the\n    resulting object is a list.\n\n    Args:\n        object_or_objects: the Python object or objects to validate and convert to a list.\n        class_: the Python type (or class) of objects expected in the list.\n        allow_none: whether or not None is a valid input (and thus output) option.\n        min_size: if provided, the length of `object_or_objects` cannot be smaller than this.\n        max_size: if provided, the length of `object_or_objects` cannot be larger than this.\n\n    Returns:\n        `object_or_objects` if it was a valid list, `[object_or_objects]` if it was a valid\n            object, or `None` if provided and allowed.\n\n    Throws:\n        InvalidUsageError: if any of the validation checks fail.\n    \"\"\"\n    if object_or_objects is None and allow_none:\n        return None\n    if object_or_objects is None and not allow_none:\n        raise InvalidUsageError(\n            f\"Type of {object_or_objects} ({type(object_or_objects)})) is \"\n            f\"None should be type `{class_}`.\"\n        )\n\n    if isinstance(object_or_objects, List):\n        items = object_or_objects\n    else:\n        items = [\n            object_or_objects,\n        ]\n\n    for item in items:\n        if not isinstance(class_, Tuple):\n            class_ = (class_,)\n        if not isinstance(item, class_):\n            raise InvalidUsageError(\n                f\"Type of {item} ({type(item)})) inconsistent with expected type {class_}.\"\n            )\n\n    if items is not None:\n        length = len(items)\n        if min_size is not None and length &lt; min_size:\n            raise InvalidUsageError(\n                f\"Size ({length}) of list of {type(class_)} is less than `min_size` ({min_size})\"\n            )\n\n        if max_size is not None and length &gt; max_size:\n            raise InvalidUsageError(\n                f\"Size ({length}) of list of {type(class_)} exceeds `max_size` ({max_size})\"\n            )\n\n    return items\n</code></pre>"},{"location":"reference/utils/#utils.is_hex","title":"is_hex","text":"<pre><code>is_hex(string)\n</code></pre> <p>Determines whether a given string is a valid hexadecimal number.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>the string to examine for hex characters.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the string is a valid hexadecimal number, otherwise <code>False</code>.</p> Source code in <code>slackblocks/utils.py</code> <pre><code>def is_hex(string: str) -&gt; bool:\n    \"\"\"\n    Determines whether a given string is a valid hexadecimal number.\n\n    Args:\n        string: the string to examine for hex characters.\n\n    Returns:\n        `True` if the string is a valid hexadecimal number, otherwise `False`.\n    \"\"\"\n    return all(char in hexdigits for char in string)\n</code></pre>"},{"location":"reference/utils/#utils.validate_action_id","title":"validate_action_id","text":"<pre><code>validate_action_id(action_id, allow_none=False)\n</code></pre> <p>Action IDs are used in the handing of user interactivity within Slack blocks. This function checks that a given <code>action_id</code> is valid as per the requirements imposed by the Slack API.</p> <p>See: https://api.slack.com/interactivity/handling</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>str</code> <p>the action_id string to validate for correctness as per the Slack API.</p> required <code>allow_none</code> <code>bool</code> <p>whether to accept <code>None</code> as a valid value for <code>action_id</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The original value <code>action_id</code> if all validation checks pass.</p> Throws <p>InvalidUsageError if any of the validation checks fail.</p> Source code in <code>slackblocks/utils.py</code> <pre><code>def validate_action_id(action_id: str, allow_none: bool = False) -&gt; Optional[str]:\n    \"\"\"\n    Action IDs are used in the handing of user interactivity within Slack blocks.\n    This function checks that a given `action_id` is valid as per the requirements\n    imposed by the Slack API.\n\n    See: &lt;https://api.slack.com/interactivity/handling&gt;\n\n    Args:\n        action_id: the action_id string to validate for correctness as per the Slack API.\n        allow_none: whether to accept `None` as a valid value for `action_id`.\n\n    Returns:\n        The original value `action_id` if all validation checks pass.\n\n    Throws:\n        InvalidUsageError if any of the validation checks fail.\n    \"\"\"\n    if action_id is None:\n        if not allow_none:\n            raise InvalidUsageError(\"`action_id` cannot be None.\")\n    else:\n        length = len(action_id)\n        if length &lt; 1:\n            raise InvalidUsageError(\"`action_id` cannot be empty.\")\n        if length &gt; 255:\n            raise InvalidUsageError(\n                f\"`action_id` length ({length}) exceeds limit of 255 characters (id: {action_id}).\"\n            )\n    return action_id\n</code></pre>"},{"location":"reference/utils/#utils.validate_int","title":"validate_int","text":"<pre><code>validate_int(\n    num, min_value=None, max_value=None, allow_none=False\n)\n</code></pre> <p>Performs basic validation checks against a given integer.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>Union[int, None]</code> <p>the number to validate.</p> required <code>min_value</code> <code>Optional[int]</code> <p>if <code>num</code> is less than this value, an error will be thrown.</p> <code>None</code> <code>max_value</code> <code>Optional[int]</code> <p>if <code>num</code> is greater than this value, an error will be thrown.</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>whether <code>None</code> is a valid value for <code>num</code>. If <code>num</code> is <code>None</code> <code>allow_none</code> is <code>False</code>, an error will be thrown.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>The original value of <code>num</code> if it passes all validation checks.</p> Throws <p>InvalidUsageError: if any of the validation checks fail.</p> Source code in <code>slackblocks/utils.py</code> <pre><code>def validate_int(\n    num: Union[int, None],\n    min_value: Optional[int] = None,\n    max_value: Optional[int] = None,\n    allow_none: bool = False,\n) -&gt; int:\n    \"\"\"\n    Performs basic validation checks against a given integer.\n\n    Args:\n        num: the number to validate.\n        min_value: if `num` is less than this value, an error will be thrown.\n        max_value: if `num` is greater than this value, an error will be thrown.\n        allow_none: whether `None` is a valid value for `num`. If `num` is `None`\n            `allow_none` is `False`, an error will be thrown.\n\n    Returns:\n        The original value of `num` if it passes all validation checks.\n\n    Throws:\n        InvalidUsageError: if any of the validation checks fail.\n    \"\"\"\n    if num is None and not allow_none:\n        raise InvalidUsageError(\"`num` is None, which is disallowed.\")\n    if min_value is not None:\n        if num &lt; min_value:\n            raise InvalidUsageError(f\"{num} is less than the minimum {min_value}\")\n    if max_value is not None:\n        if num &gt; max_value:\n            raise InvalidUsageError(f\"{num} is less than the minimum {max_value}\")\n    return num\n</code></pre>"},{"location":"reference/utils/#utils.validate_string","title":"validate_string","text":"<pre><code>validate_string(\n    string,\n    field_name,\n    max_length=None,\n    min_length=None,\n    allow_none=False,\n)\n</code></pre> <p>Performs basic validation actions (e.g. length checking) on a given string based on the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>Optional[str]</code> <p>the string to validate</p> required <code>field_name</code> <code>str</code> <p>the name of the field the string belongs to (for error reporting purposes).</p> required <code>min_length</code> <code>Optional[int]</code> <p>if the string is less than this length, an error will be raised.</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>if the string is greated than this length, an error will be raised.</p> <code>None</code> <code>allow_none</code> <code>bool</code> <p>whether <code>None</code> is a valid value for the string being validated.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The original string if it deemed to be valid (i.e. no errors are thrown).</p> Throws <p>InvalidUsageError: if any of the validation checks (length, <code>None</code>) fail.</p> Source code in <code>slackblocks/utils.py</code> <pre><code>def validate_string(\n    string: Optional[str],\n    field_name: str,\n    max_length: Optional[int] = None,\n    min_length: Optional[int] = None,\n    allow_none: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    Performs basic validation actions (e.g. length checking) on a given string\n    based on the provided criteria.\n\n    Args:\n        string: the string to validate\n        field_name: the name of the field the string belongs to (for error reporting purposes).\n        min_length: if the string is less than this length, an error will be raised.\n        max_length: if the string is greated than this length, an error will be raised.\n        allow_none: whether `None` is a valid value for the string being validated.\n\n    Returns:\n        The original string if it deemed to be valid (i.e. no errors are thrown).\n\n    Throws:\n        InvalidUsageError: if any of the validation checks (length, `None`) fail.\n    \"\"\"\n    if string is None:\n        if not allow_none:\n            raise InvalidUsageError(\n                f\"Expecting string for field `{field_name}`, cannot be None.\"\n            )\n    else:\n        length = len(string)\n        if min_length and length &lt; min_length:\n            raise InvalidUsageError(\n                f\"Argument to field `{field_name}` ({length} characters) \"\n                f\"is less than minimum length of {min_length} characters\"\n            )\n        if max_length and length &gt; max_length:\n            raise InvalidUsageError(\n                f\"Argument to field `{field_name}` ({length} characters) \"\n                f\"exceeds length limit of {max_length} characters\"\n            )\n    return string\n</code></pre>"},{"location":"reference/views/","title":"Views","text":"<p>Views are app-customized visual areas within modals and Home tabs.</p> <p>See: https://api.slack.com/reference/surfaces/views.</p>"},{"location":"reference/views/#views.HomeTabView","title":"HomeTabView","text":"<p><code>HomeTabViews</code> are used with the <code>views.publish</code> Web API method.</p> <p>See: https://api.slack.com/reference/surfaces/views#home.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>Union[Block, List[Block]]</code> <p>A list of blocks that defines the content of the view (max 100).</p> required <code>private_metadata</code> <code>Optional[str]</code> <p>a string (max 3000 chars) that will be sent to your app in <code>view_submission</code>.</p> <code>None</code> <code>callback_id</code> <code>Optional[str]</code> <p>A string that will identify submissions of this view.</p> <code>None</code> <code>external_id</code> <code>Optional[str]</code> <p>A custom identifier that is unique within the views of a given Slack team.</p> <code>None</code> Source code in <code>slackblocks/views.py</code> <pre><code>class HomeTabView(View):\n    \"\"\"\n    `HomeTabViews` are used with the `views.publish` Web API method.\n\n    See: &lt;https://api.slack.com/reference/surfaces/views#home&gt;.\n\n    Args:\n        blocks: A list of blocks that defines the content of the view (max 100).\n        private_metadata: a string (max 3000 chars) that will be sent to your app\n            in `view_submission`.\n        callback_id: A string that will identify submissions of this view.\n        external_id: A custom identifier that is unique within the views of a\n            given Slack team.\n    \"\"\"\n\n    def __init__(\n        self,\n        blocks: Union[Block, List[Block]],\n        private_metadata: Optional[str] = None,\n        callback_id: Optional[str] = None,\n        external_id: Optional[str] = None,\n    ) -&gt; \"HomeTabView\":\n        super().__init__(\n            type=ViewType.HOME,\n            blocks=blocks,\n            private_metadata=private_metadata,\n            callback_id=callback_id,\n            external_id=external_id,\n        )\n</code></pre>"},{"location":"reference/views/#views.ModalView","title":"ModalView","text":"<p>Modal views are used with the <code>views.open</code>, <code>views.update</code> and <code>views.push</code>     Slack Web API methods.</p> <p>See: https://api.slack.com/reference/surfaces/views#modal</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>TextLike</code> <p>heading that appears at the top left of the view.</p> required <code>blocks</code> <code>Union[Block, List[Block]]</code> <p>a list of blocks (max 100) that define the content of the view.</p> required <code>close</code> <code>Optional[TextLike]</code> <p>the text of the close button (max 24 chars) in the view. Must be <code>Text.PLAINTEXT</code>.</p> <code>None</code> <code>submit</code> <code>Optional[TextLike]</code> <p>the text of the submit button (max 24 chars) in the view. Must be <code>Text.PLAINTEXT</code>.</p> <code>None</code> <code>private_metadata</code> <code>Optional[str]</code> <p>a string (max 3000 chars) that will be sent to your app in <code>view_submission</code>.</p> <code>None</code> <code>callback_id</code> <code>Optional[str]</code> <p>A string that will identify submissions of this view.</p> <code>None</code> <code>clear_on_close</code> <code>Optional[bool]</code> <p>when <code>True</code> all views in the model will be cleared when it is closed.</p> <code>False</code> <code>notify_on_close</code> <code>Optional[bool]</code> <p>when <code>True</code> a <code>view_closed</code> event will be sent when the modal is closed.</p> <code>False</code> <code>external_id</code> <code>Optional[str]</code> <p>A custom identifier that is unique within the views of a given Slack team.</p> <code>None</code> <code>submit_disabled</code> <code>Optional[bool]</code> <p>when <code>True</code> disabled submitting the form until one or more inputs have been provided. Used only for <code>configuaration models</code>.</p> <code>False</code> Source code in <code>slackblocks/views.py</code> <pre><code>class ModalView(View):\n    \"\"\"\n    Modal views are used with the `views.open`, `views.update` and `views.push`\n        Slack Web API methods.\n\n    See: &lt;https://api.slack.com/reference/surfaces/views#modal&gt;\n\n    Args:\n        title: heading that appears at the top left of the view.\n        blocks: a list of blocks (max 100) that define the content of the view.\n        close: the text of the close button (max 24 chars) in the view.\n            Must be `Text.PLAINTEXT`.\n        submit: the text of the submit button (max 24 chars) in the view.\n            Must be `Text.PLAINTEXT`.\n        private_metadata: a string (max 3000 chars) that will be sent to your app\n            in `view_submission`.\n        callback_id: A string that will identify submissions of this view.\n        clear_on_close: when `True` all views in the model will be cleared when\n            it is closed.\n        notify_on_close: when `True` a `view_closed` event will be sent when the\n            modal is closed.\n        external_id: A custom identifier that is unique within the views of a\n            given Slack team.\n        submit_disabled: when `True` disabled submitting the form until one or\n            more inputs have been provided. Used only for\n            [`configuaration models`](https://api.slack.com/reference/workflows/configuration-view).\n    \"\"\"\n\n    def __init__(\n        self,\n        title: TextLike,\n        blocks: Union[Block, List[Block]],\n        close: Optional[TextLike] = None,\n        submit: Optional[TextLike] = None,\n        private_metadata: Optional[str] = None,\n        callback_id: Optional[str] = None,\n        clear_on_close: Optional[bool] = False,\n        notify_on_close: Optional[bool] = False,\n        external_id: Optional[str] = None,\n        submit_disabled: Optional[bool] = False,\n    ):\n        super().__init__(\n            type=ViewType.MODAL,\n            blocks=blocks,\n            private_metadata=private_metadata,\n            callback_id=callback_id,\n            external_id=external_id,\n        )\n        self.title = Text.to_text(title, force_plaintext=True, max_length=24)\n        self.close = Text.to_text(\n            close, force_plaintext=True, max_length=24, allow_none=True\n        )\n        self.submit = Text.to_text(\n            submit, force_plaintext=True, max_length=24, allow_none=True\n        )\n        self.clear_on_close = clear_on_close\n        self.notify_on_close = notify_on_close\n        self.submit_disabled = submit_disabled\n\n    def _resolve(self) -&gt; Dict[str, Any]:\n        modal_view = super()._resolve()\n        modal_view[\"title\"] = self.title._resolve()\n        if self.close:\n            modal_view[\"close\"] = self.close._resolve()\n        if self.submit:\n            modal_view[\"submit\"] = self.submit._resolve()\n        if self.clear_on_close:\n            modal_view[\"clear_on_close\"] = self.clear_on_close\n        if self.notify_on_close:\n            modal_view[\"notify_on_close\"] = self.notify_on_close\n        if self.submit_disabled:\n            modal_view[\"submit_disabled\"] = self.submit_disabled\n        return modal_view\n</code></pre>"},{"location":"usage/installation/","title":"Installation","text":""},{"location":"usage/installation/#installing-slackblocks","title":"Installing <code>slackblocks</code>","text":"<p>You can install <code>slackblocks</code> using any Python package manager with access to PyPI. Installation commands for some of the more popular ones are included below.</p> pippoetryPipenv <pre><code>pip install slackblocks\n</code></pre> <pre><code>poetry add slackblocks\n</code></pre> <pre><code>pipenv install slackblocks\n</code></pre> <p><code>slackblocks</code> is a pure Python package and is published automatically to PyPI as Python wheels whenever a new version is released.</p> <p>As of version `v0.1.0`` it has no dependencies outside of the Python standard library.</p>"},{"location":"usage/installation/#uninstalling-slackblocks","title":"Uninstalling <code>slackblocks</code>","text":"<p>If, for whatever reason, you need to remove <code>slackblocks</code> from your environment you can do so with the following commands:</p> pippoetryPipenv <pre><code>pip uninstall slackblocks\n</code></pre> <pre><code>poetry remove slackblocks\n</code></pre> <pre><code>pipenv uninstall slackblocks\n</code></pre>"},{"location":"usage/sending_messages/","title":"Sending Messages","text":"<p><code>slackblocks</code> is designed primarily for use with either the <code>slack-sdk</code> or (legacy) <code>slackclient</code> Python packages. Usage of <code>slackblocks</code> remains identical regardless of which Slack client library you're using.</p> <p>While there's nothing stopping you from sending the rendered messages directly with <code>curl</code> or <code>requests</code>, we recommend using the <code>**</code> (dictionary unpacking)operator to unpack <code>slackblocks</code> <code>Messages</code> directly into the Slack <code>client</code>'s <code>chat_postMessage</code> function.</p> <p>An example of this is provided below along with the JSON result of rendering the message, an equivalent <code>curl</code> command, and finally the result of the message as it appears in the Slack user interface.</p> Python (<code>slackblocks</code>)JSON MessageEquivalent <code>curl</code> CommandSlack UI Output <pre><code>from os import environ\nfrom slack import WebClient\nfrom slackblocks import Message, SectionBlock\n\n\nclient = WebClient(token=environ[\"SLACK_API_TOKEN\"])\nblock = SectionBlock(\"Hello, world!\")\nmessage = Message(channel=\"#general\", blocks=block)\n\nresponse = client.chat_postMessage(**message)\n</code></pre> <p><pre><code>{\n    \"channel\": \"#general\",\n    \"mrkdwn\": true,\n    \"blocks\": [\n        {\n            \"type\": \"section\",\n            \"block_id\": \"992ceb6b-9ad4-496b-b8e6-1bd8a632e8b3\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": \"Hello, world!\"\n            }\n        }\n    ]\n}\n</code></pre> * Note that the <code>block_id</code> field is a pseudorandomly generated UUID. You can pass a value to <code>Block</code> constructors should you desire deterministic <code>Blocks</code>.</p> <pre><code>curl -H \"Content-type: application/json\" \\\n--data '{\"channel\":\"#general\",\"blocks\":[{\"type\":\"section\", \"block_id\": \"992ceb6b-9ad4-496b-b8e6-1bd8a632e8b3\", \"text\":{\"type\":\"mrkdwn\",\"text\":\"Hello, world\"}}]}' \\\n-H \"Authorization: Bearer ${SLACK_API_TOKEN}\" \\\n-X POST https://slack.com/api/chat.postMessage\n</code></pre> <p></p>"},{"location":"usage/using_blocks/","title":"Using Blocks","text":""},{"location":"usage/using_blocks/#section-block","title":"Section Block","text":"<pre><code>A section is one of the most flexible blocks available -\nit can be used as a simple text block, or with any of the\navailable block elements.\n\nSection blocks can also optionally be given an \"accessory,\"\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream     which is typically one of the interactive     Elements. =======     which is typically one of the interactive Elements.</p> <p>Stashed changes</p> <pre><code>Args:\n    text: text to include in the block. Can be a string or `Text` object (of either\n        `mrkdwn` or `plaintext` variety). Defaults to markdown if unspecified. One of either\n        `text` or `fields` must be provided.\n    block_id: you can use this field to provide a deterministic identifier for the block.\n    fields: a list of text objects. One of either `text` or `fields` must be provided.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         accessory: an optional Element object that             will take a secondary place in the block (after or to the side of  <code>text</code> or             <code>fields</code>). =======         accessory: an optional Element object that will take a             secondary place in the block (after or to the side of  <code>text</code> or <code>fields</code>).</p> <p>Stashed changes</p> <pre><code>Throws:\n    InvalidUsageError: if any of the provided arguments fail validation checks.\n</code></pre> <code>slackblocks</code>JSONSlack UI <pre><code>from slackblocks import Checkboxes, Option, SectionBlock\n\nSectionBlock(\n    text=\"This is a section block with a checkbox accessory.\", \n    block_id=\"fake_block_id\"\n    accessory=CheckboxGroup(\n        action_id=\"checkboxes-action\",\n        options=[\n            Option(\n                text=\"*Your Only Option*\",\n                value=\"option_one\"\n            )\n        ]\n    )\n)\n</code></pre> <pre><code>{\n    \"type\": \"section\",\n    \"block_id\": \"fake_block_id\",\n    \"text\": {\n        \"type\": \"mrkdwn\",\n        \"text\": \"This is a section block with a checkbox accessory.\"\n    },\n    \"accessory\": {\n        \"type\": \"checkboxes\",\n        \"options\": [\n            {\n                \"text\": {\n                    \"type\": \"mrkdwn\",\n                    \"text\": \"*Your Only Option*\"\n                },\n                \"value\": \"option_one\"\n            }\n        ],\n        \"action_id\": \"checkboxes-action\"\n    }\n}\n</code></pre> <p></p>"},{"location":"usage/using_blocks/#rich-text-block","title":"Rich Text Block","text":"<pre><code>A RichTextBlock is used to provide easier rich text formatting\n    than standard markdown text (e.g. in a\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         <code>SectionBlock</code>)         and access to text formatting features not available in traditional         markdown (e.g. strikethrough). See the various rich text elements         you can include here. =======         <code>SectionBlock</code>)         and access to text formatting features not available in traditional         markdown (e.g. strikethrough). See the various rich text elements         you can include here.</p> <p>Stashed changes</p> <pre><code>Args:\n    elements: a single [rich text element](rich_text)\n        or a list of those elements.\n    block_id: you can use this field to provide a deterministic identifier\n        for the block.\n\nThrows:\n    InvalidUsageError: if the elements in `elements` are not valid rich\n        text elements.\n</code></pre> <code>slackblocks</code>JSONSlack UI <pre><code>from slackblock import RichTextBlock, RichTextSection, RichText\n\nRichTextBlock(\n    RichTextSection(\n        [\n            RichText(\n                \"You 'bout to witness hip-hop in its most purest\",\n                bold=True,\n            ),\n            RichText(\n                \"Most rawest form, flow almost flawless\",\n                strike=True,\n            ),\n            RichText(\n                \"Most hardest, most honest known artist\",\n                italic=True,\n            ),\n        ]\n    ),\n    block_id=\"fake_block_id\",\n)\n</code></pre> <pre><code>{\n    \"type\": \"rich_text\",\n    \"block_id\": \"fake_block_id\",\n    \"elements\": [\n        {\n            \"type\": \"rich_text_section\",\n            \"elements\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": \"You 'bout to witness hip-hop in its most purest\\n\",\n                    \"style\": {\n                        \"bold\": true\n                    }\n                },\n                {\n                    \"type\": \"text\",\n                    \"text\": \"Most rawest form, flow almost flawless\\n\",\n                    \"style\": {\n                        \"strike\": true\n                    }\n                },\n                {\n                    \"type\": \"text\",\n                    \"text\": \"Most hardest, most honest known artist\\n\",\n                    \"style\": {\n                        \"italic\": true\n                    }\n                }\n            ]\n        }\n    ]\n}\n</code></pre> <p></p>"},{"location":"usage/using_blocks/#header-block","title":"Header Block","text":"<p>A Header Block is a plain-text block that displays in a larger, bold font.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Union[str, Text]</code> <p>the text that will be rendered as a heading.</p> required <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> <code>None</code> <code>slackblocks</code>JSONSlack UI <pre><code>from slackblocks import HeaderBlock\n\nHeaderBlock(\n    \"This is a header block\",\n)\n</code></pre> <pre><code>{\n    \"type\": \"header\",\n    \"text\": {\n        \"type\": \"plain_text\",\n        \"text\": \"This is a header block\",\n        \"emoji\": true\n    }\n}\n</code></pre> <p></p>"},{"location":"usage/using_blocks/#image-block","title":"Image Block","text":"<p>An Image Block contains a single graphic, accessed by URL.</p> <p>Parameters:</p> Name Type Description Default <code>image_url</code> <code>str</code> <p>the URL pointing to the image file you want to display.</p> required <code>alt_text</code> <code>Optional[str]</code> <p>alternative text for accessibility purposes and when the image fails to load.</p> <code>' '</code> <code>title</code> <code>Optional[Union[Text, str]]</code> <p>an optional text title to be presented with the image.</p> <code>None</code> <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> <code>None</code> Throws <p>InvalidUsageError: when one or more of the provided args fails validation.</p> <code>slackblocks</code>JSONSlack UI <pre><code>from slackblocks import ImageBlock\n\nImageBlock(\n    image_url=\"https://api.slack.com/img/blocks/bkb_template_images/beagle.png\",\n    alt_text=\"a beagle\",\n    title=\"dog\",\n    block_id=\"fake_block_id\",\n)\n</code></pre> <pre><code>{\n    \"type\": \"image\",\n    \"block_id\": \"fake_block_id\",\n    \"image_url\": \"https://api.slack.com/img/blocks/bkb_template_images/beagle.png\",\n    \"alt_text\": \"a beagle\",\n    \"title\": {\n        \"type\": \"plain_text\",\n        \"text\": \"dog\"\n    }\n}\n</code></pre> <p></p>"},{"location":"usage/using_blocks/#input-block","title":"Input Block","text":"<pre><code>A block that collects information from users - it can hold a plain-text\ninput element, a checkbox element, a radio button element, a select\nmenu element, a multi-select menu element, or a datepicker.\n\nArgs:\n    label: the name which identifies the input field.\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         element: an interactive Element             (e.g. a text field).         dispatch_action: whether the Element             should trigger the sending of a <code>block_actions</code> payload. =======         element: an interactive Element (e.g. a text field).         dispatch_action: whether the Element should trigger the             sending of a <code>block_actions</code> payload.</p> <p>Stashed changes         block_id: you can use this field to provide a deterministic identifier for the block.         hint: an optional additional guide on what input the user should prodive.         optional: whether this input field may be empty when the user submits e.g. the modal.</p> <pre><code>Throws:\n    InvalidUsageError: when any of the provided arguments fail validation.\n</code></pre> <code>slackblocks</code>JSONSlack UI <pre><code>from slackblocks import InputBlock, Text, TextType, PlainTextInput\n\nInputBlock(\n    label=Text(\"Label\", type_=TextType.PLAINTEXT, emoji=True),\n    hint=Text(\"Hint\", type_=TextType.PLAINTEXT, emoji=True),\n    element=PlainTextInput(action_id=\"action\"),\n    block_id=\"fake_block_id\",\n    optional=True,\n)\n</code></pre> <pre><code>{\n    \"type\": \"input\",\n    \"block_id\": \"fake_block_id\",\n    \"label\": {\n        \"type\": \"plain_text\",\n        \"text\": \"Label\",\n        \"emoji\": true\n    },\n    \"element\": {\n        \"type\": \"plain_text_input\",\n        \"action_id\": \"action\"\n    },\n    \"hint\": {\n        \"type\": \"plain_text\",\n        \"text\": \"Hint\",\n        \"emoji\": true\n    },\n    \"optional\": true\n}\n</code></pre> <p></p>"},{"location":"usage/using_blocks/#divider-block","title":"Divider Block","text":"<p>A content divider, like an <code>&lt;hr&gt;</code> in HTML, to split up different blocks inside of a message.</p> <p>Parameters:</p> Name Type Description Default <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> <code>None</code> <code>slackblocks</code>JSONSlack UI <pre><code>from slackblocks import DividerBlock\n\nDividerBlock()\n</code></pre> <pre><code>{\n    \"type\": \"divider\"\n}\n</code></pre> <p></p>"},{"location":"usage/using_blocks/#file-block","title":"File Block","text":"<p>Displays a remote file (e.g. a PDF).</p> <p>For details on how remote files are exposed to Slack, see https://api.slack.com/messaging/files#adding.</p> <p>Parameters:</p> Name Type Description Default <code>external_id</code> <code>str</code> <p>the ID assigned to the remote file when it was added to Slack.</p> required <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> required <code>source</code> <code>str</code> <p>always \"remote\" as per the Slack API (may change in the future).</p> <code>'remote'</code> <code>slackblocks</code>JSONSlack UI <pre><code>from slackblocks import FileBlock\n\nFileBlock(\n    external_id=\"external_id\",\n    block_id=\"fake_block_id\",\n)\n</code></pre> <pre><code>{\n    \"type\": \"file\",\n    \"external_id\": \"external_id\",\n    \"source\": \"remote\",\n    \"block_id\": \"fake_block_id\"\n}\n</code></pre> <p> * Note that this example comes from the Slack Web API docs.</p>"},{"location":"usage/using_blocks/#context-block","title":"Context Block","text":"<p>A <code>ContextBlock</code> displays contextul message info, including both images and text.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Optional[List[Union[Element, CompositionObject]]]</code> <p>a list of <code>Text</code> objects and <code>Image</code> elements.</p> <code>None</code> <code>block_id</code> <code>Optional[str]</code> <p>you can use this field to provide a deterministic identifier for the block.</p> <code>None</code> Throws <p>InvalidUsageError: when items in <code>elements</code> are not <code>Text</code> or <code>Image</code> or exceed 10 items.</p> <code>slackblocks</code>JSONSlack UI <pre><code>from slackblocks import ContextBlock, Text\n\nContextBlock(\n    elements=[\n        Text(\"Hello, world!\"),\n    ], \n    block_id=\"fake_block_id\"\n)\n</code></pre> <pre><code>{\n    \"type\": \"context\",\n    \"block_id\": \"fake_block_id\",\n    \"elements\": [\n        {\n            \"type\": \"mrkdwn\",\n            \"text\": \"Hello, world!\"\n        }\n    ]\n}\n</code></pre> <p></p>"},{"location":"usage/using_blocks/#actions-block","title":"Actions Block","text":"<pre><code>A `Block` that is used to hold interactive elements (normally for users to interface with).\n\nArgs:\n</code></pre> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream         elements: a list of Elements             (up to a maximum of 25). =======         elements: a list of Elements (up to a maximum of 25).</p> <p>Stashed changes         block_id: you can use this field to provide a deterministic identifier for the block.</p> <pre><code>Throws:\n    InvalidUsageError: if any of the items in `elements` are invalid.\n</code></pre> <code>slackblocks</code>JSONSlack UI <pre><code>ActionsBlock(\n    block_id=\"fake_block_id\",\n    elements=CheckboxGroup(\n        action_id=\"actionId-0\",\n        options=[\n            Option(text=\"*a*\", value=\"a\", description=\"*a*\"),\n            Option(text=\"*b*\", value=\"b\", description=\"*b*\"),\n            Option(text=\"*c*\", value=\"c\", description=\"*c*\"),\n        ],\n    ),\n)\n</code></pre> <pre><code>{\n    \"type\": \"actions\",\n    \"block_id\": \"fake_block_id\",\n    \"elements\": [\n        {\n            \"type\": \"checkboxes\",\n            \"action_id\": \"actionId-0\",\n            \"options\": [\n                {\n                    \"text\": {\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*a*\"\n                    },\n                    \"value\": \"a\",\n                    \"description\": {\n                        \"type\": \"plain_text\",\n                        \"text\": \"*a*\"\n                    }\n                },\n                {\n                    \"text\": {\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*b*\"\n                    },\n                    \"value\": \"b\",\n                    \"description\": {\n                        \"type\": \"plain_text\",\n                        \"text\": \"*b*\"\n                    }\n                },\n                {\n                    \"text\": {\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"*c*\"\n                    },\n                    \"value\": \"c\",\n                    \"description\": {\n                        \"type\": \"plain_text\",\n                        \"text\": \"*c*\"\n                    }\n                }\n            ]\n        }\n    ]\n}\n</code></pre> <p></p>"}]}